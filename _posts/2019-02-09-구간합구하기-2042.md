---
layout: post
title: "2042번) 구간 합 구하기"
date:   2019-02-09
categories: [Algorithm]
icon: icon-cplusplus
---

# 문제
어떤 N개의 수가 주어져 있다. 그런데 중간에 수의 변경이 빈번히 일어나고 그 중간에 어떤 부분의 합을 구하려 한다. 만약에 1,2,3,4,5 라는 수가 있고, 3번째 수를 6으로 바꾸고 2번째부터 5번째까지 합을 구하라고 한다면 17을 출력하면 되는 것이다. 그리고 그 상태에서 다섯 번째 수를 2로 바꾸고 3번째부터 5번째까지 합을 구하라고 한다면 12가 될 것이다. [baekjoon](https://www.acmicpc.net/problem/2042)

<br>

# 코드

세그먼트 트리
```c++
#include "2042.h"
#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

long long init(vector<long long> &inputValues, vector<long long> &segmentTree, int node, int start, int end) {
    if (start == end) return segmentTree[node] = inputValues[start];

    return segmentTree[node] =
            init(inputValues, segmentTree, 2 * node, start, (start + end) / 2) +
            init(inputValues, segmentTree, 2 * node + 1, (start + end) / 2 + 1, end);
}

void update(vector<long long> &segmentTree, int node, int start, int end, int idx, long long diff) {
    if (idx < start || idx > end) return;
    segmentTree[node] += diff;

    if (start != end) {
        update(segmentTree, 2 * node, start, (start + end) / 2, idx, diff);
        update(segmentTree, 2 * node + 1, (start + end) / 2 + 1, end, idx, diff);
    }
}

long long sum(vector<long long> &segmentTree, int node, int start, int end, int left, int right) {
    if (right < start || left > end) return 0;

    if (left <= start && right >= end) return segmentTree[node];

    return sum(segmentTree, 2 * node, start, (start + end) / 2, left, right) +
            sum(segmentTree, 2 * node + 1, (start + end) / 2 + 1, end, left, right);
}

void solve_2042() {
    int n, m, k;
    scanf("%d %d %d", &n, &m, &k);

    vector<long long> inputValues(n + 1);
    for (int i = 1; i <= n; i++) scanf("%lld", &inputValues[i]);

    // 세그먼트 트리 생성
    int treeHeight = (int) ceil(log2(n));
    int treeSize = 1 << (treeHeight + 1);
    vector<long long> segmentTree(treeSize);
    init(inputValues, segmentTree, 1, 1, n);

    int oper = m + k;
    while (oper-- > 0) {
        int inputCase;
        scanf("%d", &inputCase);
        if (inputCase == 1) {
            // update
            int idx;
            long long newValue;
            scanf("%d %lld", &idx, &newValue);

            long long diff = newValue - inputValues[idx];
            inputValues[idx] = newValue;
            update(segmentTree, 1, 1, n, idx, diff);
        } else {
            // 구간합
            int from, to;
            scanf("%d %d", &from, &to);

            printf("%lld\n", sum(segmentTree, 1, 1, n, from, to));
        }
    }
}
```

펜윅 트리
```c++
#include "2042.h"
#include <iostream>
#include <vector>

using namespace std;

void update(vector<long long> &fenwickTree, int idx, long long diff) {
    while (idx < fenwickTree.size()) {
        fenwickTree[idx] += diff;
        idx += (idx & -idx);
    }
}

long long sum(vector<long long> &fenwickTree, int to) {
    long long result = 0;
    while (to > 0) {
        result += fenwickTree[to];
        to -= (to & -to);
    }
    return result;
}

void solve_2042() {
    int n, m, k;
    scanf("%d %d %d", &n, &m, &k);

    vector<long long> inputValues(n + 1);
    vector<long long> fenwickTree(n + 1);

    // tree init
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &inputValues[i]);
        update(fenwickTree, i, inputValues[i]);
    }

    int oper = m + k;
    while (oper-- > 0) {
        int inputCase;
        scanf("%d", &inputCase);
        if (inputCase == 1) {
            // update
            int idx;
            long long newValue;
            scanf("%d %lld", &idx, &newValue);

            update(fenwickTree, idx, newValue - inputValues[idx]);
            inputValues[idx] = newValue;
        } else {
            // 구간합
            int from, to;
            scanf("%d %d", &from, &to);

            printf("%lld\n", sum(fenwickTree, to) - sum(fenwickTree, from - 1));
        }
    }
}
```

<br>

# 풀이
(세그먼트 트리)  
[세그먼트 트리(Segment Tree)](https://www.acmicpc.net/blog/view/9)

(펜윅 트리)  
값이 계속해서 바뀌는데 구간합을 구하는 문제로, [펜윅 트리(Fenwick Tree)](https://greeksharifa.github.io/algorithm%20&%20data%20structure/2018/07/09/algorithm-fenwick-tree/)를 이용하면 된다.  
-idx는 ~idx + 1과 같다.
