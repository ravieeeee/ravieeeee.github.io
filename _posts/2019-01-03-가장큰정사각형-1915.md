---
layout: post
title: "1915번) 가장 큰 정사각형"
date:   2019-01-03
categories: [Algorithm]
icon: icon-java
---

# 문제
n×m의 0, 1로 된 배열이 있다. 이 배열에서 1로 된 가장 큰 정사각형의 크기를 구하는 프로그램을 작성하시오.

| 0 | 1 | 0 | 0 |
|---|---|---|---|
| 0 | 1 | 1 | 1 |
| 1 | 1 | 1 | 0 |
| 0 | 0 | 1 | 0 |

위와 같은 예제에서는 가운데의 2×2 배열이 가장 큰 정사각형이다. [baekjoon](https://www.acmicpc.net/problem/1915)

<br>

# 코드
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class 가장큰정사각형_1915 {
    static int n, m, max;
    static boolean[][] isChecked;
    static int[][] dp;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        isChecked = new boolean[n + 1][m + 1];
        boolean doesInclude1 = false;
        for (int i = 1; i <= n; i++) {
            String line = br.readLine();
            for (int j = 1; j <= m; j++) {
                isChecked[i][j] = (line.charAt(j - 1) == '1');
                if (isChecked[i][j]) doesInclude1 = true;
            }
        }
        br.close();

        dp = new int[n + 1][m + 1];
        max = 0;
        for (int x = 1; x <= n; x++) {
            for (int y = 1; y <= m; y++) {
                getSquare(x, y);
                if (dp[x][y] > max) max = dp[x][y];
            }
        }

        if (max == 0 && doesInclude1) {
            System.out.println(1);
            return;
        } else if (max == 0 && !doesInclude1) {
            System.out.println(0);
            return;
        }
        System.out.println((max + 1) * (max + 1));
    }

    static void getSquare(int x, int y) {
        if (n - x <= max || m - y <= max) { return; }

        int chain = (dp[x - 1][y - 1] > 1) ? dp[x - 1][y - 1] : 1;

        while (x + chain <= n && y + chain <= m) {
            for (int i = 0; i <= chain; i++) {
                if (!isChecked[x + i][y + chain] || !isChecked[x + chain][y + i]) return;
            }
            dp[x][y] = chain++;
        }
    }
}
```

<br>

# 풀이
일단 현재 탐색하는 지점을 정사각형의 왼쪽 상단 지점을 시작으로 하여 만들 수 있는 최대 정사각형의 크기를 구하도록 만들었다. 정사각형이 커져갈수록 chain의 크기를 늘려서 해당 chain 단계에 input이 1이여야 하는지 확인하는 방식이다. dp[x][y]에는 (x, y) 좌표를 왼쪽 상단으로 하는 정사각형의 한 변의 길이 - 1 값이 들어가게 된다.

전체를 다 탐색하기에는 시간 초과가 나기 때문에 탐색량을 줄이기 위한 트릭 1개와 탐색을 하지 않을 트릭 1개를 추가했다.  
먼저, 탐색량을 줄이기 위해서 새로 만들려는 정사각형이 상위 정사각형의 범위에 속하는지 확인해서, 만약 속한다면 chain의 크기를 jump시킬 수 있도록 했다. 이는 dp[i - 1][j - 1] 즉, 대각선 방향의 정사각형의 최대 크기가 2이상이어야만 가능하다. 0이면 아예 포함관계가 없고, 1이면 포함은 되지만 자식 정사각형이 상위 정사각형에 속하지 않는 범위의 정사각형을 만들 수 있기 때문에 더 큰 정사각형을 만들어 낼 가능성이 있기 때문이다.  
탐색을 하지 않기 위한 수단으로는, 현재 조사할려는 위치에서 최대로 만들 수 있는 정사각형의 크기가 지금까지의 최대 정사각형의 크기보다 커지지 않는지를 확인했다. 지금까지의 max값보다 큰 정사각형을 만들기 위해서는 입력받은 배열의 크기를 넘어서야 한다면 더이상 조사할 가치가 없기 때문이다. 아예 조사하지 않기 때문에 특정 입력 case(조사 초반에 엄청 큰 정사각형을 발견한다던지)에서는 이 부분에서 시간 단축이 상당히 많이 일어난다.
