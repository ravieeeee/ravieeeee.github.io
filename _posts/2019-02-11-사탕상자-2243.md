---
layout: post
title: "2243번) 사탕상자"
date:   2019-02-11
categories: [Algorithm]
icon: icon-cplusplus
---

# 문제
수정이는 어린 동생을 달래기 위해서 사탕을 사용한다. 수정이는 평소에 여러 개의 사탕을 사서 사탕상자에 넣어두고, 동생이 말을 잘 들을 때면 그 안에서 사탕을 꺼내서 주곤 한다.

각각의 사탕은 그 맛의 좋고 나쁨이 1부터 1,000,000까지의 정수로 구분된다. 1이 가장 맛있는 사탕을 의미하며, 1,000,000은 가장 맛없는 사탕을 의미한다. 수정이는 동생이 말을 잘 들은 정도에 따라서, 사탕상자 안에 있는 사탕들 중 몇 번째로 맛있는 사탕을 꺼내주곤 한다. 예를 들어 말을 매우 잘 들었을 때에는 사탕상자에서 가장 맛있는 사탕을 꺼내주고, 말을 조금 잘 들었을 때에는 사탕상자에서 여섯 번째로 맛있는 사탕을 꺼내주는 식이다.

수정이가 보관하고 있는 사탕은 매우 많기 때문에 매번 사탕상자를 뒤져서 꺼낼 사탕을 골라내는 일은 매우 어렵다. 수정이를 도와주는 프로그램을 작성하시오. [baekjoon](https://www.acmicpc.net/problem/2243)

<br>

# 코드
```c++
#include "2243.h"
#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

void update(vector<int> &segmentTree, int node, int start, int end, int idx, int diff) {
    if (idx < start || idx > end) return;
    segmentTree[node] += diff;

    if (start != end) {
        update(segmentTree, 2 * node, start, (start + end) / 2, idx, diff);
        update(segmentTree, 2 * node + 1, (start + end) / 2 + 1, end, idx, diff);
    }
}

int findValue(vector<int> &segmentTree, int node, int start, int end, int b) {
    if (start == end) return start;

    if (b <= segmentTree[node * 2]) return findValue(segmentTree, 2 * node, start, (start + end) / 2, b);
    else {
        b -= segmentTree[node * 2];
        return findValue(segmentTree, 2 * node + 1, (start + end) / 2 + 1, end, b);
    }
}

void solve_2243() {
    int n;
    scanf("%d", &n);

    // 사탕 맛 종류의 최대 개수
    int candy = 1000000;

    // 세그먼트 트리 생성
    int treeHeight = (int) ceil(log2(candy));
    int treeSize = 1 << (treeHeight + 1);
    vector<int> segmentTree(treeSize);

    while (n-- > 0) {
        int a;
        scanf("%d", &a);

        if (a == 1) {
            int b;
            scanf("%d", &b);

            int idx = findValue(segmentTree, 1, 1, candy, b);
            printf("%d\n", idx);
            update(segmentTree, 1, 1, candy, idx, -1);
        } else {
            int b, c;
            scanf("%d %d", &b, &c);

            update(segmentTree, 1, 1, candy, b, c);
        }
    }
}
```

<br>

# 풀이
어떻게 트리를 만들어가야할지 너무 헷갈리고 어려운 문제였다.. [풀이](https://www.crocus.co.kr/668)를 참고했다.  

일단 트리는 특정 사탕 맛에 대한 사탕의 개수를 담는 구조다. leaf node에는 해당 맛의 개수를 담게 된다.  
헷갈렸던게, leaf node는 (start(=end), start(=end))까지의 값을 담당하므로 해당 leaf node에 도착했을 때 그 맛의 번호는 start(=end)다. node 변수는 노드번호만을 의미하므로 문제에서 자식 트리를 접근하는데만 이용된다. 그래서 findValue에서 찾은 사탕 맛을 idx 변수로 받아 diff를 -1을 주는 update를 한다. b값에 대한 업데이트가 아니다!  

참고한 풀이에서는 자식 노드의 누적합을 체크하는 과정에서 트리의 노드 개수 범위를 넘어서는지 체크하는 부분(node * 2 <= tree_size)이 있던데 사실 필요없다. 트리의 노드 개수 범위를 넘어서는 경우는 leaf node에서 node * 2를 계산하는 경우다. 하지만 leaf node의 경우에는 findValue 함수의 첫번째 if문에서 이미 return값을 뱉고 빠져나가기 때문이다.
