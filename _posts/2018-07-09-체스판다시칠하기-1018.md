---
layout: post
title: "1018번) 체스판 다시 칠하기"
date:   2018-07-09
categories: [Algorithm]
icon: icon-java
---

# 문제
지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 MxN크기의 보드를 찾았다. 어떤 정사각형은 검정색으로 칠해져있고, 나머지는 흰색으로 칠해져 있다. 지민이는이 보드를 잘라서 8x8크기의 체스판으로 만드려고 한다.

하지만 지민이는 이 보드가 체스판처럼 검정/흰색 패턴이 번갈아가며 색칠해져있지 않기 때문에 고민에 빠졌다. 따라서 지민이는 8x8크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야 겠다고 생각했다. 당연히 8x8크기는 아무데서나 골라도 된다.

현재 보드의 색이 어떤지 상태가 주어질 때, 지민이가 8x8크기로 자른 뒤에 다시 칠해야하는 정사각형 개수의 최솟값을 구하는 프로그램을 작성하시오.

체스판은 각 정사각형이 검정 또는 흰색이며, 변을 공유하는 두 개의 사각형이 같은 색이 아닐 때 이다. 따라서 위 정의에 의하면 체스판의 색은 항상 두 가지가 가능한데, 하나는 왼쪽 위 코너가 흰색인 것, 검정색인 것 두가지이다. [baekjoon](https://www.acmicpc.net/problem/1018)

<br>

# 코드
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class 체스판다시칠하기_1018 {
    static char[][] c;
    static int n, m;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        c = new char[n][m];

        for (int i = 0; i < n; i++) {
            String s = br.readLine();
            for (int j = 0; j < m; j++) {
                c[i][j] = s.charAt(j);
            }
        }

        int r = 0;
        for (int i = 0; i <= n - 8; i++) {
            for (int j = 0; j <= m - 8; j++) {
                if (i == 0 && j == 0) r = Math.min(findSmallOne('W', i, j), findSmallOne('B', i, j));
                else {
                    r = Math.min(r, findSmallOne('W', i, j));
                    r = Math.min(r, findSmallOne('B', i, j));
                }
            }
        }
        System.out.println(r);
    }

    static int findSmallOne(char f, int n1, int m1) {
        int r = 0, n2 = n1 + 8, m2 = m1 + 8;
        char f2 = f;
        for (int i = n1; i < n2; i++) {
            for (int j = m1; j < m2; j++) {
                if (c[i][j] != f) r++;
                f = (f == 'W') ? 'B' : 'W';
            }
            f = (f2 == 'W') ? 'B' : 'W';
            f2 = f;
        }
        return r;
    }
}
```

<br>

# 풀이
이렇게 다 안찾고 첫 시작이 B나 W중에 하나만 구해도 그 반대는 64에서 빼주면 구할 수 있다.