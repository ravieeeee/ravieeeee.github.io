---
layout: post
title: "3943번) 헤일스톤 수열"
date:   2018-08-03
categories: [Algorithm]
icon: icon-java
---

# 문제
헤일스톤 수열은 다음과 같이 정의 한다.

* n이 짝수라면, 2로 나눈다.

* n이 홀수라면, 3을 곱한 뒤 1로 더한다.

헤일스톤 추측은 임의의 양의 정수 n으로 수열을 시작한다면, 항상 4, 2, 1, 4, 2, 1,...로 끝난다는 추측이다. 이 문제에서는 1이 나오면 수열이 끝난 것으로 처리한다.

n이 주어졌을 때, 이 수열에서 가장 큰 값을 찾아 출력하는 프로그램을 작성하시오. [baekjoon](https://www.acmicpc.net/problem/3943)

<br>

# 코드
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class 헤일스톤수열_3943 {
    static int[] memo;
    static int n;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int t = Integer.parseInt(br.readLine());
        StringBuilder sb = new StringBuilder();
        memo = new int[100001];
        for (int i = 1; i <= 100000; i *= 2) memo[i] = i;

        while (t-- > 0) {
            n = Integer.parseInt(br.readLine());
            sb.append(getMax(n) + "\n");
        }
        System.out.println(sb.deleteCharAt(sb.length() - 1));
    }

    static int getMax(int m) {
        if (m <= 100000 && memo[m] != 0) return memo[m];

        if (m % 2 == 0) {
            return memo[n] = Math.max(m, getMax(m / 2));
        } else {
            return memo[n] = Math.max(m, getMax(3 * m + 1));
        }
    }
}
```

<br>

# 풀이
divide된 소문제들은 문제 자체에 정의가 되어있다. 메모이제이션으로 memo[n]에는 n에 대한 헤일스톤 수열의 최댓값이 들어간다. 배열에 대한 인덱스는 항상 n이여야 하므로 복제본이라 할 수 있는 m을 계속해서 변화시켜서 최댓값을 구해가도록 했다.
