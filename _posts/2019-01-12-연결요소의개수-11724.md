---
layout: post
title: "11724번) 연결 요소의 개수"
date:   2019-01-12
categories: [Algorithm]
icon: icon-java
---

# 문제
방향 없는 그래프가 주어졌을 때, 연결 요소 (Connected Component)의 개수를 구하는 프로그램을 작성하시오.  [baekjoon](https://www.acmicpc.net/problem/11724)

<br>

# 코드
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class 연결요소의개수_11724 {
    static int n;
    static boolean[][] graph;
    static boolean[] isVisited;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        isVisited = new boolean[n + 1];
        graph = new boolean[n + 1][n + 1];
        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());
            int from = Integer.parseInt(st.nextToken()), to = Integer.parseInt(st.nextToken());
            graph[from][to] = graph[to][from] = true;
        }
        br.close();

        int result = 0;
        for (int i = 1; i <= n; i++) {
            if (!isVisited[i]) {
                result++;
                dfs(i);
            }
        }
        System.out.println(result);
    }

    static void dfs(int start) {
        isVisited[start] = true;

        for (int i = 1; i <= n; i++) {
            if (graph[start][i] && !isVisited[i]) {
                dfs(i);
            }
        }
    }
}
```

<br>

# 풀이
.
