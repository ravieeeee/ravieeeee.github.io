---
layout: post
title: "2698번) 인접한 비트의 개수"
date:   2018-08-13
categories: [Algorithm]
icon: icon-java
---

# 문제
0과 1로 이루어진 수열 S가 있다. S의 첫 수는 s1이고, 마지막 수는 sn이다. S의 인접한 비트의 개수는 다음과 같이 구할 수 있다.

s1*s2 + s2*s3 + s3*s4 + ... + sn-1 * sn

위의 식을 이용하면 수열 S에서 인접한 1의 개수를 구할 수 있다. 예를들어, 011101101의 인접한 비트의 개수는 3이 되고, 111101101은 4, 010101010은 0이 된다.

수열 S의 크기 n과 k가 주어졌을 때, 인접한 비트의 개수가 k인 수열 S의 개수를 구하는 프로그램을 작성하시오.

예를 들어, n이 5이고, k가 2이면, 수열 S가 될 수 있는 수열은 다음과 같이 6가지가 있다.

11100, 01110, 00111, 10111, 11101, 11011 [baekjoon](https://www.acmicpc.net/problem/2698)

<br>

# 코드
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class 인접한비트의개수_2698 {
    public static void main(String[] args) throws IOException {
        int[][][] dp = new int[101][100][2];

        dp[1][0][0] = 1;
        dp[1][0][1] = 1;
        for (int i = 2; i < 101; i++) {
            for (int j = 0; j < 100; j++) {
                dp[i][j][0] = dp[i - 1][j][0] + dp[i - 1][j][1];
                dp[i][j][1] = (j == 0) ? dp[i - 1][j][0] : dp[i - 1][j][0] + dp[i - 1][j - 1][1];
            }
        }

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();

        int t = Integer.parseInt(br.readLine());
        while (t-- > 0) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int n = Integer.parseInt(st.nextToken());
            int k = Integer.parseInt(st.nextToken());

            sb.append(dp[n][k][0] + dp[n][k][1] + "\n");
        }
        System.out.println(sb.deleteCharAt(sb.length() - 1));
    }
}
```

<br>

# 풀이
.