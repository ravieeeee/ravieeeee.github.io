---
layout: post
title: "2146번) 다리 만들기"
date:   2019-03-29
categories: [Algorithm]
icon: icon-cplusplus
---

# 문제
여러 섬으로 이루어진 나라가 있다. 이 나라의 대통령은, 섬들을 잇는 다리를 만들겠다는 공약으로 인기몰이를 해 당선될 수 있었다. 하지만 막상 대통령에 취임하자, 다리를 놓는다는 것이 아깝다는 생각을 하게 되었다. 그래서 그는, 생색내는 식으로 한 섬과 다른 섬을 잇는 다리 하나만을 만들기로 하였고, 그 또한 다리를 가장 짧게 하여 돈을 아끼려 하였다.

이 나라는 N×N크기의 이차원 평면상에 존재한다. 이 나라는 여러 섬으로 이루어져 있으며, 섬이란 동서남북으로 육지가 붙어있는 덩어리를 말한다. 다음은 세 개의 섬으로 이루어진 나라의 지도이다.

![](https://www.acmicpc.net/JudgeOnline/upload/201008/bri.PNG)

위의 그림에서 색이 있는 부분이 육지이고, 색이 없는 부분이 바다이다. 이 바다에 가장 짧은 다리를 놓아 두 대륙을 연결하고자 한다. 가장 짧은 다리란, 다리가 격자에서 차지하는 칸의 수가 가장 작은 다리를 말한다. 다음 그림에서 두 대륙을 연결하는 다리를 볼 수 있다.

![](https://www.acmicpc.net/JudgeOnline/upload/201008/b2.PNG)

물론 위의 방법 외에도 다리를 놓는 방법이 여러 가지 있으나, 위의 경우가 놓는 다리의 길이가 3으로 가장 짧다(물론 길이가 3인 다른 다리를 놓을 수 있는 방법도 몇 가지 있다).

지도가 주어질 때, 가장 짧은 다리 하나를 놓아 두 대륙을 연결하는 방법을 찾으시오. [baekjoon](https://www.acmicpc.net/problem/2146)

<br>

# 코드
```c++
#include "2146.h"
#include <iostream>
#include <queue>

using namespace std;

int graph[101][101];
int new_graph[101][101];
bool is_visited[101][101];
int n, bridge = 100 * 100;

struct Node {
    int x; int y;
    int depth;
    int land_num; // 해당 노드의 섬 번호
};

void dfs(int x, int y, int land_num) {
    is_visited[x][y] = true;
    new_graph[x][y] = land_num;

    // 상
    if (x - 1 > 0 && graph[x - 1][y] == 1 && !is_visited[x - 1][y]) dfs(x - 1, y, land_num);
    // 하
    if (x + 1 <= n && graph[x + 1][y] == 1 && !is_visited[x + 1][y]) dfs(x + 1, y, land_num);
    // 좌
    if (y - 1 > 0 && graph[x][y - 1] == 1 && !is_visited[x][y - 1]) dfs(x, y - 1, land_num);
    // 우
    if (y + 1 <= n && graph[x][y + 1] == 1 && !is_visited[x][y + 1]) dfs(x, y + 1, land_num);
}

void bfs(int x, int y) {
    int min_bridge_len_of_start = n * n; // 시작점으로부터의 다리를 짓는 임시적 min값
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) is_visited[i][j] = false;
    }

    queue<Node> q;
    Node node = { x, y, 0, new_graph[x][y] }; // node.land_num는 시작 노드의 섬 번호
    q.push(node);
    is_visited[x][y] = true;

    while (!q.empty()) {
        Node cur = q.front();
        if (cur.land_num != new_graph[x][y]) {
            // 새로운 섬을 만남
            if (min_bridge_len_of_start > cur.depth) min_bridge_len_of_start = cur.depth;
        }
        q.pop();

        // 방문 조건: 시작 노드의 섬 번호와 다르거나 바다일 때
        // 즉, 현재 섬 번호와 같지 않을 때
        // 상
        if (cur.x - 1 > 0 && new_graph[cur.x - 1][cur.y] != cur.land_num && !is_visited[cur.x - 1][cur.y]) {
            bool is_new_land = new_graph[cur.x - 1][cur.y] != 0;
            // depth: 새로운 섬이면 그대로(바다에 다리는 다 지은거니까), 바다면 +1
            // land: 새로운 섬이면 new_graph에서 새 섬번호, 바다면 시작 노드의 섬 번호로 설정
            Node tmp = { cur.x - 1, cur.y, is_new_land ? cur.depth : cur.depth + 1, is_new_land ? new_graph[cur.x - 1][cur.y] : cur.land_num };
            q.push(tmp);
            is_visited[x - 1][y] = true;
        }
        // 하
        if (cur.x + 1 <= n && new_graph[cur.x + 1][cur.y] != cur.land_num && !is_visited[cur.x + 1][cur.y]) {
            bool is_new_land = new_graph[cur.x + 1][cur.y] != 0;
            Node tmp = { cur.x + 1, cur.y, is_new_land ? cur.depth : cur.depth + 1, is_new_land ? new_graph[cur.x + 1][cur.y] : cur.land_num };
            q.push(tmp);
            is_visited[cur.x + 1][cur.y] = true;
        }
        // 좌
        if (cur.y - 1 > 0 && new_graph[cur.x][cur.y - 1] != cur.land_num && !is_visited[cur.x][cur.y - 1]) {
            bool is_new_land = new_graph[cur.x][cur.y - 1] != 0;
            Node tmp = { cur.x, cur.y - 1, is_new_land ? cur.depth : cur.depth + 1, is_new_land ? new_graph[cur.x][cur.y - 1] : cur.land_num };
            q.push(tmp);
            is_visited[cur.x][cur.y - 1] = true;
        }
        // 우
        if (cur.y + 1 <= n && new_graph[cur.x][cur.y + 1] != cur.land_num && !is_visited[cur.x][cur.y + 1]) {
            bool is_new_land = new_graph[cur.x][cur.y + 1] != 0;
            Node tmp = { cur.x, cur.y + 1, is_new_land ? cur.depth : cur.depth + 1, is_new_land ? new_graph[cur.x][cur.y + 1] : cur.land_num };
            q.push(tmp);
            is_visited[cur.x][cur.y + 1] = true;
        }
    }

    if (bridge > min_bridge_len_of_start) bridge = min_bridge_len_of_start;
}

void solve_2146() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) cin >> graph[i][j];
    }

    int land_num = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (graph[i][j] == 1 && !is_visited[i][j]) {
                dfs(i, j, land_num);
                land_num++;
            }
        }
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (new_graph[i][j] != 0) {
                // 육지 각 점에서 BFS
                bfs(i, j);
            }
        }
    }
    cout << bridge;
}
```

<br>

# 풀이

input으로 받은 지도는 모든 육지가 1로 표기되어 있지만, DFS를 수행해서 하나의 섬끼리만 같은 번호를 갖는 새 지도(new_graph)를 만든다.    
그 후에 육지의 각 점에서 BFS를 수행하는데, 방문할 수 있는 점은 바다 혹은 시작점과 다른 섬 번호를 가지는 육지로만 한정한다. 바다를 방문하며 depth를 늘려 다리를 짓다가 다른 섬을 발견하면 그때까지 지은 다리의 수를 본다. 각각의 BFS 시작점(육지)마다 최소 다리 수가 나올 것이고, 그중에서도 최솟값을 찾아 출력한다.

2차원 bool 배열이 함수 내에서 선언될 때 당연히 초기값으로 다 false일거라고 생각했는데 아무 값이나 가지더라.. 아직도 그 기준을 잘 모르겠다. 초기화 방식을 알아두던지 언제 초기화가 필요한지를 알아두던지 둘 중 하나는 알아둬야겠다.
