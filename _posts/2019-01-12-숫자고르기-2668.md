---
layout: post
title: "2668번) 숫자고르기"
date:   2019-01-12
categories: [Algorithm]
icon: icon-java
---

# 문제
세로 두 줄, 가로로 N개의 칸으로 이루어진 표가 있다. 첫째 줄의 각 칸에는 정수 1, 2, …, N이 차례대로 들어 있고 둘째 줄의 각 칸에는 1이상 N이하인 정수가 들어 있다. 첫째 줄에서 숫자를 적절히 뽑으면, 그 뽑힌 정수들이 이루는 집합과, 뽑힌 정수들의 바로 밑의 둘째 줄에 들어있는 정수들이 이루는 집합이 일치한다. 이러한 조건을 만족시키도록 정수들을 뽑되, 최대로 많이 뽑는 방법을 찾는 프로그램을 작성하시오. 예를 들어, N=7인 경우 아래와 같이 표가 주어졌다고 하자.

![](https://www.acmicpc.net/upload/images/u5JZnfExdtFXjmR.png)

이 경우에는 첫째 줄에서 1, 3, 5를 뽑는 것이 답이다. 첫째 줄의 1, 3, 5밑에는 각각 3, 1, 5가 있으며 두 집합은 일치한다. 이때 집합의 크기는 3이다. 만약 첫째 줄에서 1과 3을 뽑으면, 이들 바로 밑에는 정수 3과 1이 있으므로 두 집합이 일치한다. 그러나, 이 경우에 뽑힌 정수의 개수는 최대가 아니므로 답이 될수 없다. [baekjoon](https://www.acmicpc.net/problem/2668)

<br>

# 코드
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;

public class 숫자고르기_2668 {
    static ArrayList<Integer>[] graph;
    static boolean[] isVisited;
    static ArrayList<Integer> cycle;
    static int cycleIndex;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        graph = new ArrayList[n + 1];
        for (int i = 1; i <= n; i++) {
            graph[i] = new ArrayList<>();
            graph[i].add(Integer.parseInt(br.readLine()));
        }
        br.close();

        isVisited = new boolean[n + 1];
        int result = 0;
        for (int i = 1; i <= n; i++) {
            if (!isVisited[i]) {
                cycle = new ArrayList<>();
                cycleIndex = -1;
                dfs(i);

                if (cycleIndex != -1) {
                    for (int j = cycleIndex; j < cycle.size(); j++) {
                        result++;
                        isVisited[cycle.get(j)] = true;
                    }
                }
            }
        }

        StringBuilder sb = new StringBuilder();
        sb.append(result + "\n");
        for (int i = 1; i <= n; i++) { if (isVisited[i]) { sb.append(i + "\n"); } }
        System.out.println(sb.deleteCharAt(sb.length() - 1));
    }

    static void dfs(int v) {
        if (isVisited[v]) { return; }

        if (!cycle.contains(v)) {
            cycle.add(v);
            for (int i : graph[v]) { dfs(i); }
        } else {
            cycleIndex = cycle.indexOf(v);
        }
    }
}
```

<br>

# 풀이
그래프는 윗칸 정수 -> 아랫칸 정수 방향으로 간선을 그려서 만든다. 그려진 그래프에 대해서 사이클을 이루는 연결 요소의 개수를 찾으면 문제에서 원하는 최대 크기의 집합을 구할 수 있게 된다.  
이를 위해서 DFS를 수행하는데, 방문 정점에 대해 전역적으로 관리하는 것은 이미 발견된 사이클에 대해서만 방문했다고 표시한다. 왜냐하면 이미 방문한 적이 있더라도 index 순차적으로 방문함은 물론 양방향 그래프가 아니기 때문에 뒤늦게 사이클이 발견될 수 있기 때문이다.  
각각의 연결 요소는 cycle이라는 배열 내에 담게 된다. 이미 cycle 내에 있는 정점(방문한 정점)에 다시 방문하는 경우 해당 정점부터 사이클이 시작되는 것이므로 cycleIndex를 update하고, 사이클을 이루는 정점들에 대해 새로운 사이클을 생성하는 경우는 없으므로 전역으로 관리되는 isVisitied를 true로 만든다. 따라서 마지막에는 isVisitied가 true인 정점들에 대해서만 사이클들이 이루어진 것으로 판단할 수 있다.
