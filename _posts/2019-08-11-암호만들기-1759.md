---
layout: post
title: "1759번) 암호 만들기"
date:   2019-08-11
categories: [Algorithm]
icon: icon-cplusplus
---

# 문제
바로 어제 최백준 조교가 방 열쇠를 주머니에 넣은 채 깜빡하고 서울로 가 버리는 황당한 상황에 직면한 조교들은, 702호에 새로운 보안 시스템을 설치하기로 하였다. 이 보안 시스템은 열쇠가 아닌 암호로 동작하게 되어 있는 시스템이다.

암호는 서로 다른 L개의 알파벳 소문자들로 구성되며 최소 한 개의 모음과 최소 두 개의 자음으로 구성되어 있다고 알려져 있다. 또한 정렬된 문자열을 선호하는 조교들의 성향으로 미루어 보아 암호를 이루는 알파벳이 암호에서 증가하는 순서로 배열되었을 것이라고 추측된다. 즉, abc는 가능성이 있는 암호이지만 bac는 그렇지 않다.

새 보안 시스템에서 조교들이 암호로 사용했을 법한 문자의 종류는 C가지가 있다고 한다. 이 알파벳을 입수한 민식, 영식 형제는 조교들의 방에 침투하기 위해 암호를 추측해 보려고 한다. C개의 문자들이 모두 주어졌을 때, 가능성 있는 암호들을 모두 구하는 프로그램을 작성하시오. [baekjoon](https://www.acmicpc.net/problem/1759)

<br>

# 코드
```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

void solve_1759() {
    int l, c;
    cin >> l >> c;

    vector<string> v;
    for (int i = 0; i < c; i++) {
        string tmp;
        cin >> tmp;
        v.push_back(tmp);
    }
    sort(v.begin(), v.end());

    vector<int> indexes;
    for (int i = 0; i < l; i++) indexes.push_back(i);

    vector<string> vowel {"a", "e", "i", "o", "u"};

    while (true) {
        // 모음, 자음 체크
        bool is_include_vowel = false;
        int count_consonant = 0;
        for (int i = 0; i < l; i++) {
            string current = v[indexes[i]];
            if (find(vowel.begin(), vowel.end(), current) != vowel.end()) {
                is_include_vowel = true;
            } else {
                count_consonant++;
            }
        }

        // 출력
        if (is_include_vowel && count_consonant > 1) {
            for (int i = 0; i < l; i++) cout << v[indexes[i]];
            cout << endl;
        }

        bool is_end = false;
        int index_helper = 1;
        // 인덱스 증가
        for (int i = l - 1; i >= 0; i--) {
            // 증가할 수 있는 최대 인덱스에 도달하지 않았다면
            if (indexes[i] != c - index_helper) {
                indexes[i]++;
                // 그 이후의 값들을 바꿔주는 과정
                for (int j = 1; i + j < l; j++) indexes[i + j] = indexes[i] + j;
                break;
            }
            index_helper++;
            if (i == 0) is_end = true;
        }
        if (is_end) break;
    }
}
```

<br>

# 풀이
문자열을 입력받아서 알파벳 순으로 정렬한다. l이 변수값이기 때문에 for loop의 수를 임의로 지정할 수 없어서 현재 가져올 값의 인덱스를 관리하는 vector(indexes)를 사용했다. 이걸 바탕으로 현재 가리키는 문자열들이 모음 1개, 자음 2개 조건을 만족하는지 체크해서, 만족한다면 출력한다. 다음 출력을 위해서 인덱스를 증가시켜야 하는데, 각각의 indexes 내 값들은 도달할 수 있는 값이 for loop로 구현했을 때의 2번째 조건값이 된다. 이를 조건문에서 체크하고, 인덱스를 증가시킬 수 있다면 그 다음 인덱스들도 영향을 받게 된다. 예를 들면, 0 1 4 5 -> 0 2 3 4 가 되어 2번째 값의 변화는 3, 4번째 값을 변화시킨다. 제일 바깥쪽 for loop 값에 해당하는 인덱스를 바꿀 수 없게 되면 더이상 출력할 새로운 문자열은 없기 떄문에 종료한다.
