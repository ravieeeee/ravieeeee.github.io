---
layout: post
title: "10026번) 적록색약"
date:   2019-01-10
categories: [Algorithm]
icon: icon-java
---

# 문제
적록색약은 빨간색과 초록색의 차이를 거의 느끼지 못한다. 따라서, 적록색약인 사람이 보는 그림은 아닌 사람이 보는 그림과는 좀 다를 수 있다.

크기가 N×N인 그리드의 각 칸에 R(빨강), G(초록), B(파랑) 중 하나를 색칠한 그림이 있다. 그림은 몇 개의 구역으로 나뉘어져 있는데, 구역은 같은 색으로 이루어져 있다. 또, 같은 색상이 상하좌우로 인접해 있는 경우에 두 글자는 같은 구역에 속한다. (색상의 차이를 거의 느끼지 못하는 경우도 같은 색상이라 한다)

예를 들어, 그림이 아래와 같은 경우에  
RRRBB  
GGBBB  
BBBRR  
BBRRR  
RRRRR  
적록색약이 아닌 사람이 봤을 때 구역의 수는 총 4개이다. (빨강 2, 파랑 1, 초록 1) 하지만, 적록색약인 사람은 구역을 3개 볼 수 있다. (빨강-초록 2, 파랑 1)

그림이 입력으로 주어졌을 때, 적록색약인 사람이 봤을 때와 아닌 사람이 봤을 때 구역의 수를 구하는 프로그램을 작성하시오. [baekjoon](https://www.acmicpc.net/problem/10026)

<br>

# 코드
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;

public class 적록색약_10026 {
    static char[][] c;
    static boolean[][] isVisited;
    static int n;

    static class Vertex {
        int i, j;

        public Vertex(int i, int j) {
            this.i = i;
            this.j = j;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        n = Integer.parseInt(br.readLine());
        c = new char[n + 1][n + 1];
        for (int i = 1; i <= n; i++) {
            String line = br.readLine();
            for (int j = 1; j <= n; j++) { c[i][j] = line.charAt(j - 1); }
        }
        br.close();

        StringBuilder sb = new StringBuilder();
        isVisited = new boolean[n + 1][n + 1];
        int cnt = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (!isVisited[i][j]) {
                    Vertex start = new Vertex(i, j);
                    countGroups(start, true);
                    cnt++;
                }
            }
        }
        sb.append(cnt + " ");

        cnt = 0;
        isVisited = new boolean[n + 1][n + 1];
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (!isVisited[i][j]) {
                    Vertex start = new Vertex(i, j);
                    countGroups(start, false);
                    cnt++;
                }
            }
        }
        sb.append(cnt);

        System.out.println(sb);
    }

    static void countGroups(Vertex start, boolean isNormal) {
        Queue<Vertex> queue = new LinkedList<>();
        queue.offer(start);
        isVisited[start.i][start.j] = true;

        while (!queue.isEmpty()) {
            Vertex v = queue.poll();
            if (isNormal) {
                // 상
                if (v.i != 1 && !isVisited[v.i - 1][v.j] && c[v.i - 1][v.j] == c[v.i][v.j]) {
                    queue.offer(new Vertex(v.i - 1, v.j));
                    isVisited[v.i - 1][v.j] = true;
                }
                // 하
                if (v.i != n && !isVisited[v.i + 1][v.j] && c[v.i + 1][v.j] == c[v.i][v.j]) {
                    queue.offer(new Vertex(v.i + 1, v.j));
                    isVisited[v.i + 1][v.j] = true;
                }
                // 좌
                if (v.j != 1 && !isVisited[v.i][v.j - 1] && c[v.i][v.j - 1] == c[v.i][v.j]) {
                    queue.offer(new Vertex(v.i, v.j - 1));
                    isVisited[v.i][v.j - 1] = true;
                }
                // 우
                if (v.j != n && !isVisited[v.i][v.j + 1] && c[v.i][v.j + 1] == c[v.i][v.j]) {
                    queue.offer(new Vertex(v.i, v.j + 1));
                    isVisited[v.i][v.j + 1] = true;
                }
            } else {
                // 상
                if (v.i != 1 && !isVisited[v.i - 1][v.j] &&
                        (c[v.i - 1][v.j] == c[v.i][v.j] ||
                                (c[v.i][v.j] == 'R' && c[v.i - 1][v.j] == 'G') ||
                                (c[v.i][v.j] == 'G' && c[v.i - 1][v.j] == 'R')
                        )
                    ) {
                    queue.offer(new Vertex(v.i - 1, v.j));
                    isVisited[v.i - 1][v.j] = true;
                }
                // 하
                if (v.i != n && !isVisited[v.i + 1][v.j] &&
                        (c[v.i + 1][v.j] == c[v.i][v.j] ||
                                (c[v.i][v.j] == 'R' && c[v.i + 1][v.j] == 'G') ||
                                (c[v.i][v.j] == 'G' && c[v.i + 1][v.j] == 'R')
                        )
                    ) {
                    queue.offer(new Vertex(v.i + 1, v.j));
                    isVisited[v.i + 1][v.j] = true;
                }
                // 좌
                if (v.j != 1 && !isVisited[v.i][v.j - 1] &&
                        (c[v.i][v.j - 1] == c[v.i][v.j] ||
                                (c[v.i][v.j] == 'R' && c[v.i][v.j - 1] == 'G') ||
                                (c[v.i][v.j] == 'G' && c[v.i][v.j - 1] == 'R')
                        )
                    ) {
                    queue.offer(new Vertex(v.i, v.j - 1));
                    isVisited[v.i][v.j - 1] = true;
                }
                // 우
                if (v.j != n && !isVisited[v.i][v.j + 1] &&
                        (c[v.i][v.j + 1] == c[v.i][v.j] ||
                                (c[v.i][v.j] == 'R' && c[v.i][v.j + 1] == 'G') ||
                                (c[v.i][v.j] == 'G' && c[v.i][v.j + 1] == 'R')
                        )
                    ) {
                    queue.offer(new Vertex(v.i, v.j + 1));
                    isVisited[v.i][v.j + 1] = true;
                }
            }
        }

    }
}
```

<br>

# 풀이
정상인 사람에 대해 BFS, 색약인 사람에 대해 BFS를 각각 진행했다. 정상인 경우 기존 BFS에서 방문할 queue에 넣는 조건으로 시작점과 색깔이 같은 것을 추가적으로 넣었고, 색약인 경우에는 시작점과 색깔이 같거나 현재 G고 상하좌우 방향에 대해서 R 혹은 그 반대인 경우를 추가 조건으로 넣었다. isVisited 배열을 통해 방문했는지를 체크하므로 시작점이 생기는 순간 어떤 색이든 색깔 그룹 하나가 생기게 되므로 countGroups 함수가 수행될 때마다 그룹의 수를 추가시켰다.
