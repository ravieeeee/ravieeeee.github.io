---
layout: post
title: "1753번) 최단경로"
date:   2018-12-20
categories: [Algorithm]
icon: icon-java
---

# 문제
방향그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램을 작성하시오. 단, 모든 간선의 가중치는 10 이하의 자연수이다. [baekjoon](https://www.acmicpc.net/problem/1753)

<br>

# 코드
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

public class 최단경로_1753 {
    static class Edge implements Comparable<Edge> {
        private int destination;
        private int weight;

        public Edge(int destination, int weight) {
            this.destination = destination;
            this.weight = weight;
        }

        @Override
        public int compareTo(Edge o) {
            return this.weight - o.weight;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int v = Integer.parseInt(st.nextToken());
        int e = Integer.parseInt(st.nextToken());
        int start = Integer.parseInt(br.readLine());

        boolean[] isVisited = new boolean[v + 1];
        int[] d = new int[v + 1];

        ArrayList<Edge>[] graph = new ArrayList[v + 1];
        for (int i = 1; i <= v; i++) {
            d[i] = Integer.MAX_VALUE;
            graph[i] = new ArrayList<>();
        }

        for (int i = 0; i < e; i++) {
            st = new StringTokenizer(br.readLine());
            int u = Integer.parseInt(st.nextToken());
            int dest = Integer.parseInt(st.nextToken());
            int w = Integer.parseInt(st.nextToken());
            graph[u].add(new Edge(dest, w));
        }
        d[start] = 0;
        br.close();

        PriorityQueue<Edge> queue = new PriorityQueue<>();
        queue.add(new Edge(start, 0));

        while (!queue.isEmpty()) {
            Edge minValue = queue.poll();
            if (isVisited[minValue.destination]) continue;
            isVisited[minValue.destination] = true;
            for (Edge cEdge : graph[minValue.destination]) {
                if (!isVisited[cEdge.destination]) {
                    d[cEdge.destination] = Math.min(d[cEdge.destination],
                            d[minValue.destination] + cEdge.weight);
                    queue.add(new Edge(cEdge.destination, d[cEdge.destination]));
                }
            }
        }

        StringBuilder sb = new StringBuilder();
        for (int i = 1; i <= v; i++) {
            int finalWeight = d[i];
            sb.append(((finalWeight == Integer.MAX_VALUE) ? "INF" : finalWeight) + "\n");
        }
        System.out.println(sb.deleteCharAt(sb.length() - 1));
    }
}
```

<br>

# 풀이
[다익스트라 알고리즘](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%81%AC%EC%8A%A4%ED%8A%B8%EB%9D%BC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)을 이용하면 되는 문제다!

간선(Edge)을 표현하는 내부 class를 정의한다. 필드로는 간선의 끝방향을 가리키는 정점의 번호인 destination과 해당 정점의 weight다. 

d[n]은 시작 정점(start)부터 정점 n까지의 최소 경로의 값을 갖는다. 초기에는 시작 정점을 제외하곤 모두 무한대 값(Integer.MAX_VALUE)이다. 그래프는 인접 리스트로 표현하고, graph[n]에는 n번째 정점이 출발점인 한 Edge들이 저장된다. 우선순위 큐(PriorityQueue)에는 최단 경로를 조사하는 중 그 순간마다 최소 경로로 갈 수 있는 Edge들이 저장된다. 저장돼있는 Edge들 중에 가장 weight가 가장 적은 Edge를 선택하기 위해 우선순위 큐를 사용했다. 이미 방문한 정점에 대해서는 조사할 필요가 없으므로, isVisited 배열을 통해 관리하도록 했다.

출발 정점을 시작으로 하여, graph 배열에서 연결돼있는 정점들에 대해 최단 경로를 업데이트하고, 우선순위 큐에 넣는 방식을 반복한다. 갈 수 있는 정점들에 대해서 모두 조사가 끝난 경우(경로가 없는 경우 INF), 결과를 출력한다.
