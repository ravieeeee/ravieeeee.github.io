---
layout: post
title: "1987번) 알파벳"
date:   2019-03-28
categories: [Algorithm]
icon: icon-cplusplus
---

# 문제
세로 R칸, 가로 C칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸 (1행 1열) 에는 말이 놓여 있다.

말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다. 즉, 같은 알파벳이 적힌 칸을 두 번 지날 수 없다.

좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단의 칸도 포함된다. [baekjoon](https://www.acmicpc.net/problem/1987)

<br>

# 코드
```c++
#include "1987.h"
#include <iostream>

using namespace std;

char graph[21][21];
bool is_visited[26];
int r, c, result;

void dfs(int x, int y, int depth) {
    is_visited[(int) graph[x][y] - 65] = true;
    // 상
    if (x - 1 > 0 && !is_visited[(int) graph[x - 1][y] - 65]) {
        dfs(x - 1, y, depth + 1);
        is_visited[(int) graph[x - 1][y] - 65] = false;
    }
    // 하
    if (x + 1 <= r && !is_visited[(int) graph[x + 1][y] - 65]) {
        dfs(x + 1, y, depth + 1);
        is_visited[(int) graph[x + 1][y] - 65] = false;
    }
    // 좌
    if (y - 1 > 0 && !is_visited[(int) graph[x][y - 1] - 65]) {
        dfs(x, y - 1, depth + 1);
        is_visited[(int) graph[x][y - 1] - 65] = false;
    }
    // 우
    if (y + 1 <= c && !is_visited[(int) graph[x][y + 1] - 65]) {
        dfs(x, y + 1, depth + 1);
        is_visited[(int) graph[x][y + 1] - 65] = false;
    }

    if (result < depth) result = depth;
}

void solve_1987() {
    cin >> r >> c;
    for (int i = 1; i <= r; i++) {
        string line;
        cin >> line;
        for (int j = 1; j <= c; j++) graph[i][j] = line.at(j - 1);
    }
    result = 0;
    dfs(1, 1, 1);
    cout << result;
}
```

<br>

# 풀이
다른 경로로 DFS로 탐색해야 하는 경우, 다른 경로에서의 DFS에서 수행된 is_visited 배열이 쓰이면 안된다. 그래서 바로 방문점에 대해서 false로 바꿔주었다.
