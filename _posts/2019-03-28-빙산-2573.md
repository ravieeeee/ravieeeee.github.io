---
layout: post
title: "2573번) 빙산"
date:   2019-03-28
categories: [Algorithm]
icon: icon-cplusplus
---

# 문제
지구 온난화로 인하여 북극의 빙산이 녹고 있다. 빙산을 그림 1과 같이 2차원 배열에 표시한다고 하자. 빙산의 각 부분별 높이 정보는 배열의 각 칸에 양의 정수로 저장된다. 빙산 이외의 바다에 해당되는 칸에는 0이 저장된다. 그림 1에서 빈칸은 모두 0으로 채워져 있다고 생각한다.

![](https://www.acmicpc.net/upload/images/PKxZvV7MUcqRHIe.png)

빙산의 높이는 바닷물에 많이 접해있는 부분에서 더 빨리 줄어들기 때문에, 배열에서 빙산의 각 부분에 해당되는 칸에 있는 높이는 일년마다 그 칸에 동서남북 네 방향으로 붙어있는 0이 저장된 칸의 개수만큼 줄어든다. 단, 각 칸에 저장된 높이는 0보다 더 줄어들지 않는다. 바닷물은 호수처럼 빙산에 둘러싸여 있을 수도 있다. 따라서 그림 1의 빙산은 일년후에 그림 2와 같이 변형된다.

그림 3은 그림 1의 빙산이 2년 후에 변한 모습을 보여준다. 2차원 배열에서 동서남북 방향으로 붙어있는 칸들은 서로 연결되어 있다고 말한다. 따라서 그림 2의 빙산은 한 덩어리이지만, 그림 3의 빙산은 세 덩어리로 분리되어 있다.

![](https://www.acmicpc.net/upload/images/nlDR8UUcvmNppi.png)

한 덩어리의 빙산이 주어질 때, 이 빙산이 두 덩어리 이상으로 분리되는 최초의 시간(년)을 구하는 프로그램을 작성하시오. 그림 1의 빙산에 대해서는 2가 답이다. 만일 전부 다 녹을 때까지 두 덩어리 이상으로 분리되지 않으면 프로그램은 0을 출력한다. [baekjoon](https://www.acmicpc.net/problem/2573)

<br>

# 코드
```c++
#include "2573.h"
#include <iostream>

using namespace std;

int graph[300][300], graph2[300][300];
bool is_visited[300][300];
int n, m;

void dfs(int x, int y) {
    is_visited[x][y] = true;
    // 상
    if (x - 1 > 0 && !is_visited[x - 1][y] && graph[x - 1][y] != 0) dfs(x - 1, y);
    // 하
    if (x + 1 < n - 1 && !is_visited[x + 1][y] && graph[x + 1][y] != 0) dfs(x + 1, y);
    // 좌
    if (y - 1 > 0 && !is_visited[x][y - 1] && graph[x][y - 1] != 0) dfs(x, y - 1);
    // 우
    if (y + 1 < m - 1 && !is_visited[x][y + 1] && graph[x][y + 1] != 0) dfs(x, y + 1);
}

void solve_2573() {
    cin >> n >> m;
    int start_x = 0, start_y = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> graph[i][j];
            graph2[i][j] = graph[i][j];
            if (graph[i][j] != 0 && start_x == 0 && start_y == 0) {
                start_x = i; start_y = j;
            }
        }
    }

    int year = 0;
    bool exit_flag = false;
    while (true) {
        // DFS check -> return
        if (year != 0) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) is_visited[i][j] = false;
            }
        }
        dfs(start_x, start_y);

        int num_of_seas = 0;
        for (int i = 0; i < n; i++) {
            if (exit_flag) break;

            for (int j = 0; j < m; j++) {
                if (graph[i][j] != 0 && !is_visited[i][j]) {
                    exit_flag = true;
                    break;
                }
                else if (graph[i][j] == 0) num_of_seas++;
            }

            if (num_of_seas == n * m) {
                year = 0;
                exit_flag = true;
            }
        }
        if (exit_flag) break;

        // update graph
        for (int i = 1; i < n - 1; i++) {
            for (int j = 1; j < m - 1; j++) {
                // 바다인가
                if (graph[i][j] == 0) continue;

                int dec = 0;
                // 상
                if (graph[i - 1][j] == 0) dec++;
                // 하
                if (graph[i + 1][j] == 0) dec++;
                // 좌
                if (graph[i][j - 1] == 0) dec++;
                // 우
                if (graph[i][j + 1] == 0) dec++;

                graph2[i][j] -= dec;
                if (graph2[i][j] < 0) graph2[i][j] = 0;
            }
        }

        // graph 복제 & 새로운 시작점 찾기
        start_x = 0; start_y = 0;
        for (int i = 1; i < n - 1; i++) {
            for (int j = 1; j < m - 1; j++) {
                graph[i][j] = graph2[i][j];
                if (graph[i][j] != 0 && start_x == 0 && start_y == 0) {
                    start_x = i; start_y = j;
                }
            }
        }
        year++;
    }

    cout << year;
}
```

<br>

# 풀이
빙산인 첫 점(start_x, start_y)부터 DFS를 수행해 남는 빙산이 있어지면 while loop를 나가고, 모두 빙산인 경우에도 year를 0으로 만든 후 나간다.  
만약 탈출 조건에 안 맞았다면, 각 점에 대해서 상하좌우를 살펴서 그래프를 업데이트한다. 이 때 각 점마다 바로 업데이트를 하면 이전에 빙산이었던 점이 바다로 바뀌면서 다른 점에 영향을 줄 수 있기 때문에 복제본인 graph2를 이용하여 새로운 값으로 갱신한다.  
새로운 그래프가 만들어지면, 원래의 그래프로 옮기고 새로운 DFS 시작점을 찾는다.
