---
layout: post
title: "1021번) 회전하는 큐"
date:   2019-08-16
categories: [Algorithm]
icon: icon-cplusplus
---

# 문제
지민이는 N개의 원소를 포함하고 있는 양방향 순환 큐를 가지고 있다. 지민이는 이 큐에서 몇 개의 원소를 뽑아내려고 한다.

지민이는 이 큐에서 다음과 같은 3가지 연산을 수행할 수 있다.

1. 첫 번째 원소를 뽑아낸다. 이 연산을 수행하면, 원래 큐의 원소가 a1, ..., ak이었던 것이 a2, ..., ak와 같이 된다.
2. 왼쪽으로 한 칸 이동시킨다. 이 연산을 수행하면, a1, ..., ak가 a2, ..., ak, a1이 된다.
3. 오른쪽으로 한 칸 이동시킨다. 이 연산을 수행하면, a1, ..., ak가 ak, a1, ..., ak-1이 된다.

큐에 처음에 포함되어 있던 수 N이 주어진다. 그리고 지민이가 뽑아내려고 하는 원소의 위치가 주어진다. (이 위치는 가장 처음 큐에서의 위치이다.) 이때, 그 원소를 주어진 순서대로 뽑아내는데 드는 2번, 3번 연산의 최솟값을 출력하는 프로그램을 작성하시오. [baekjoon](https://www.acmicpc.net/problem/1021)

<br>

# 코드
```c++
#include <iostream>
#include <vector>

using namespace std;

void solve_1021() {
    int n, m;
    cin >> n >> m;

    vector<int> questions(m);
    for (int i = 0; i < m; i++) cin >> questions[i];

    vector<int> v(n);
    for (int i = 1; i <= n; i++) v[i - 1] = i;

    int result = 0;
    for (int i = 0; i < m; i++) {
        int find_num = questions[i];

        for (int j = 0; j < n; j++) {
            if (v[j] == find_num) {
                if (j != 0) {
                    // 최소 연산 수 찾기
                    if (j < int(v.size()) - j) {
                        result += j;
                        for (int k = 0; k < j; k++) {
                            int tmp = v.front();
                            v.erase(v.begin());
                            v.push_back(tmp);
                        }
                    } else {
                        result += int(v.size()) - j;
                        for (int k = 0; k < int(v.size()) - j; k++) {
                            int tmp = v.back();
                            v.pop_back();
                            v.insert(v.begin(), tmp);
                        }
                    }
                }
                v.erase(v.begin());
                break;
            }
        }
    }

    cout << result << endl;
}
```

<br>

# 풀이
.
