---
layout: post
title: "11403번) 경로 찾기"
date:   2019-02-17
categories: [Algorithm]
icon: icon-cplusplus
---

# 문제
가중치 없는 방향 그래프 G가 주어졌을 때, 모든 정점 (i, j)에 대해서, i에서 j로 가는 경로가 있는지 없는지 구하는 프로그램을 작성하시오. [baekjoon](https://www.acmicpc.net/problem/11403)

<br>

# 코드
```c++
#include "11403.h"
#include <iostream>
#include <vector>

using namespace std;

const int MAX_SIZE = 101;
vector<int> graph[MAX_SIZE];
bool isValid;

void dfs(vector<bool> &isVisited, int i, int j) {
    isVisited[i] = true;

    vector<int> connected = graph[i];
    for (int k : connected) {
        if (k == j) isValid = true;
        else if (!isVisited[k]) dfs(isVisited, k, j);
    }
}

void solve_11403() {
    int n;
    scanf("%d", &n);

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            int input;
            scanf("%d", &input);
            if (input != 0) graph[i].push_back(j);
        }
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            vector<bool> isVisited(n + 1);
            isValid = false;
            dfs(isVisited, i, j);
            printf("%d ", isValid ? 1 : 0);
        }
        printf("\n");
    }
}
```

<br>

# 풀이
i(1 <= i <= n)부터 j(1 <= i <= n)까지의 경로가 존재하는지를 i를 시작점으로 한 dfs를 통해 찾는다. 
