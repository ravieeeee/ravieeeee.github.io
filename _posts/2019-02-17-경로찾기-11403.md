---
layout: post
title: "11403번) 경로 찾기"
date:   2019-02-17
categories: [Algorithm]
icon: icon-cplusplus
---

# 문제
가중치 없는 방향 그래프 G가 주어졌을 때, 모든 정점 (i, j)에 대해서, i에서 j로 가는 경로가 있는지 없는지 구하는 프로그램을 작성하시오. [baekjoon](https://www.acmicpc.net/problem/11403)

<br>

# 코드
```c++
#include "11403.h"
#include <iostream>
#include <vector>

using namespace std;

bool isValid;

void dfs(vector<vector<int>> &graph, vector<bool> &isVisited, int i, int j) {
    isVisited[i] = true;

    vector<int> connected = graph[i];
    for (int k = 1; k < connected.size(); k++) {
        if (connected[k] == 1) {
            if (k == j) isValid = true;
            else if (!isVisited[k]) dfs(graph, isVisited, k, j);
        }
    }
}

void solve_11403() {
    int n;
    scanf("%d", &n);

    vector<vector<int>> graph(n + 1);
    for (int i = 1; i <= n; i++) graph[i].resize(n + 1);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) scanf("%d", &graph[i][j]);
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            vector<bool> isVisited(n + 1);
            isValid = false;
            dfs(graph, isVisited, i, j);
            printf("%d ", isValid ? 1 : 0);
        }
        printf("\n");
    }
}
```

<br>

# 풀이
i(1 <= i <= n)부터 j(1 <= i <= n)까지의 경로가 존재하는지를 i를 시작점으로 한 dfs를 통해 찾는다. 
