---
layout: post
title: "11048번) 이동하기"
date:   2018-07-10
categories: [Algorithm]
icon: icon-java
---

# 문제
준규는 N×M 크기의 미로에 갇혀있다. 미로는 1×1크기의 방으로 나누어져 있고, 각 방에는 사탕이 놓여져 있다. 미로의 가장 왼쪽 윗 방은 (1, 1)이고, 가장 오른쪽 아랫 방은 (N, M)이다.

준규는 현재 (1, 1)에 있고, (N, M)으로 이동하려고 한다. 준규가 (r, c)에 있으면, (r+1, c), (r, c+1), (r+1, c+1)로 이동할 수 있고, 각 방을 방문할 때마다 방에 놓여져있는 사탕을 모두 가져갈 수 있다. 또, 미로 밖으로 나갈 수는 없다.

준규가 (N, M)으로 이동할 때, 가져올 수 있는 사탕 개수의 최대값을 구하시오. [baekjoon](https://www.acmicpc.net/problem/11048)

<br>

# 코드
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class 이동하기_11048 {
    static int[][] a;
    static int[][] memo;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken()), m = Integer.parseInt(st.nextToken());

        a = new int[n][m];
        memo = new int[n][m];
        for (int i = 0; i < n; i++) {
            st = new StringTokenizer(br.readLine(), " ");
            for (int j = 0; j < m; j++) {
                a[i][j] = Integer.parseInt(st.nextToken());
                memo[i][j] = -1;
            }
        }

        System.out.println(findMax(n - 1, m - 1));
    }

    static int findMax(int x, int y) {
        if (x < 0 || y < 0) return 0;

        if (x == 0 && y == 0) return memo[0][0] = a[0][0];

        if (memo[x][y] != -1) return memo[x][y];

        return memo[x][y] = a[x][y] + Math.max(Math.max(findMax(x - 1, y), findMax(x, y -1)),
                findMax(x - 1, y - 1));
    }
}
```

<br>

# 풀이
[정수 삼각형](https://www.acmicpc.net/problem/1932)이랑 이 문제가 가장 기초적인 dp 문제인 것 같다. 두 문제가 느낌이 비슷하다.

재귀로 작성한 다음에 생각해보니 top-down 방식이라 인덱스 범위를 넘어가는 경우가 분명히 생길 수 있었다. 그래서 아예 엎고 반복문으로 찾아야하나 생각했는데 그냥 재귀함수 내에서 인덱스 범위에 속하지 않으면 바로 짤라버렸다!
