---
layout: post
title: "2357번) 최솟값과 최댓값"
date:   2019-02-09
categories: [Algorithm]
icon: icon-cplusplus
---

# 문제
N(1 ≤ N ≤ 100,000)개의 정수들이 있을 때, a번째 정수부터 b번째 정수까지 중에서 제일 작은 정수, 또는 제일 큰 정수를 찾는 것은 어려운 일이 아니다. 하지만 이와 같은 a, b의 쌍이 M(1 ≤ M ≤ 100,000)개 주어졌을 때는 어려운 문제가 된다. 이 문제를 해결해 보자.

여기서 a번째라는 것은 입력되는 순서로 a번째라는 이야기이다. 예를 들어 a=1, b=3이라면 입력된 순서대로 1번, 2번, 3번 정수 중에서 최소, 최댓값을 찾아야 한다. 각각의 정수들은 1이상 1,000,000,000이하의 값을 갖는다. [baekjoon](https://www.acmicpc.net/problem/2357)

<br>

# 코드
```c++
#include "2357.h"
#include <iostream>
#include <vector>
#include <cmath>
#include <climits>

using namespace std;

pair<long long, long long> init(vector<long long> &inputValues, vector<pair<long long, long long>> &segmentTree, int node, int start, int end) {
    if (start == end) {
        pair<long long, long long> values = make_pair(inputValues[start], inputValues[start]);
        return segmentTree[node] = values;
    }

    pair<long long, long long> leftTree = init(inputValues, segmentTree, 2 * node, start, (start + end) / 2);
    pair<long long, long long> rightTree = init(inputValues, segmentTree, 2 * node + 1, (start + end) / 2 + 1, end);

    return segmentTree[node] = make_pair(min(leftTree.first, rightTree.first), max(leftTree.second, rightTree.second));
}

pair<long long, long long> findValue(vector<pair<long long, long long>> &segmentTree, int node, int start, int end, int left, int right) {
    if (right < start || left > end) {
        return make_pair(LLONG_MAX, 0);
    }

    if (left <= start && right >= end) {
        return segmentTree[node];
    }

    pair<long long, long long> leftTree = findValue(segmentTree, 2 * node, start, (start + end) / 2, left, right);
    pair<long long, long long> rightTree = findValue(segmentTree, 2 * node + 1, (start + end) / 2 + 1, end, left, right);

    return make_pair(min(leftTree.first, rightTree.first), max(leftTree.second, rightTree.second));
}

void solve_2357() {
    int n, m;
    scanf("%d %d", &n, &m);

    vector<long long> inputValues(n + 1);
    for (int i = 1; i <= n; i++) scanf("%lld", &inputValues[i]);

    int treeHeight = (int) ceil(log2(n));
    int treeSize = 1 << (treeHeight + 1);
    vector<pair<long long, long long>> segmentTree(treeSize);
    init(inputValues, segmentTree, 1, 1, n);

    while (m-- > 0) {
        int a, b;
        scanf("%d %d", &a, &b);

        pair<long long, long long> value = findValue(segmentTree, 1, 1, n, a, b);
        printf("%lld %lld\n", value.first, value.second);
    }
}
```

<br>

# 풀이
세그먼트 트리의 노드들이 부분합을 가지는 대신, 어떤 범위의 pair<최솟값, 최댓값>을 갖도록 했다.  
findValue 함수에서 구하고자 하는 left~right가 현재 노드가 담당하는 범위인 start~end에 속하지 않는 경우, 최솟값과 최댓값에 영향을 주지 않기 위해 long long의 최대값을 min 자리에 주고 모든 input값은 0보다 크기 때문에 max 자리에는 0을 줬다.
