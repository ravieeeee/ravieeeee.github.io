---
layout: post
title: "SWEA 7733번) 치즈 도둑"
date:   2019-08-19
categories: [Algorithm]
icon: icon-cplusplus
---

# 문제
[SWEA](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWrDOdQqRCUDFARG)

<br>

# 코드
```c++
#include "7733.h"
#include <iostream>
#include <queue>

using namespace std;

void solve_7733() {
    int tc;
    cin >> tc;

    for (int t = 1; t <= tc; t++) {
        int n;
        cin >> n;

        int graph[n][n], is_ate[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                cin >> graph[i][j];
                is_ate[i][j] = false;
            }
        }

        int result = 0;
        for (int day = 1; day < 101; day++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (graph[i][j] == day) is_ate[i][j] = true;
                }
            }

            // BFS
            queue<pair<int, int>> q;
            int is_visited[n][n];
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    is_visited[i][j] = false;
                }
            }

            int cnt = 0;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (!is_ate[i][j] && !is_visited[i][j]) {
                        q.push(pair<int, int>(i, j));
                        is_visited[i][j] = true;

                        while (!q.empty()) {
                            pair<int, int> cur = q.front();
                            q.pop();

                            // 상
                            if (cur.first - 1 >= 0 && !is_ate[cur.first - 1][cur.second] && !is_visited[cur.first - 1][cur.second]) {
                                q.push(pair<int, int>(cur.first - 1, cur.second));
                                is_visited[cur.first - 1][cur.second] = true;
                            }
                            // 하
                            if (cur.first + 1 < n && !is_ate[cur.first + 1][cur.second] && !is_visited[cur.first + 1][cur.second]) {
                                q.push(pair<int, int>(cur.first + 1, cur.second));
                                is_visited[cur.first + 1][cur.second] = true;
                            }
                            // 좌
                            if (cur.second - 1 >= 0 && !is_ate[cur.first][cur.second - 1] && !is_visited[cur.first][cur.second - 1]) {
                                q.push(pair<int, int>(cur.first, cur.second - 1));
                                is_visited[cur.first][cur.second - 1] = true;
                            }
                            // 우
                            if (cur.second + 1 < n && !is_ate[cur.first][cur.second + 1] && !is_visited[cur.first][cur.second + 1]) {
                                q.push(pair<int, int>(cur.first, cur.second + 1));
                                is_visited[cur.first][cur.second + 1] = true;
                            }
                        }
                        cnt++;
                    }
                }
            }
            result = max(result, cnt);
        }
        // 0개일때 예외처리
        result = max(1, result);
        cout << "#" << t << " " << result << endl;
    }
}
```

<br>

# 풀이
.
