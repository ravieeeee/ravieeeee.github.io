---
layout: post
title: "SWEA 3459번) 승자 예측하기"
date:   2019-04-10
categories: [Algorithm]
icon: icon-cplusplus
---

# 문제
[SWEA](https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWFPoj1qANoDFAV0&categoryId=AWFPoj1qANoDFAV0&categoryType=CODE)

<br>

# 코드
```c++
#include "3459.h"
#include <algorithm>

using namespace std;

void solve_3459() {
    int tc;
    scanf("%d", &tc);

    for (int i = 1; i <= tc; i++) {
        long long n;
        scanf("%lld", &n);

        if (n == 1) {
            printf("#%d Bob\n", i);
            continue;
        }

        if (n == 2 || n == 3) {
            printf("#%d Alice\n", i);
            continue;
        }

        long long next_layer_value = 4;
        int layer = 1;
        while (true) {
            if (n < next_layer_value) break;
            next_layer_value *= 2;
            layer++;
        }

        long long value = 1;
        if (layer % 2 == 1) {
            // Alice
            for (int j = 1; j <= layer; j++) {
                // Alice
                if (j % 2 == 1) value *= 2;
                // Bob
                else value = value * 2 + 1;
            }
            printf("#%d %s\n", i, (n < value) ? "Bob" : "Alice");
        } else {
            // Bob
            for (int j = 1; j <= layer; j++) {
                // Alice
                if (j % 2 == 1) value = value * 2 + 1;
                // Bob
                else value *= 2;
            }
            printf("#%d %s\n", i, (n < value) ? "Alice" : "Bob");
        }
    }
}
```

<br>

# 풀이
먼저, 받은 n이 어느 layer에 속하는지를 찾는다. 이 때 미리 layer의 첫번째 값을 입력 범위까지 찾아놓고 lower_bound를 통해 layer를 찾으면 시간초과다..  
문제에서 말하는 최선의 방법을 찾아야 하는데, n이 속한 layer에서 대답할 사람의 입장에서 생각해봐야 한다. n을 상한선이라고 하면, 대답할 사람은 하한선을 최대한 작은 수까지 끌어내려 하한선 ~ 상한선(n)까지의 범위를 최대한 넓혀놓는 것이 최선이다. 따라서 마지막에 대답할 사람은 최대한 작은 값(value *= 2)을 계속해서 대답하려고 할 것이고, 그 반대사람은 최대한 큰 값(value = value * 2 + 1)을 대답하려고 할 것이다.  
해당 layer가 홀수면 Alice가 대답할 차례고 짝수면 Bob이 대답할 차례가 된다. 이에 따라 최선의 하한선을 찾은 후, 그 범위에 속하면 대답할 차례인 사람이 이기고 속하지 않으면 다른 사람이 이긴다.
