---
layout: post
title: "1614번) 영식이의 손가락"
date:   2018-06-06
categories: [Algorithm]
icon: icon-java
---

# 문제
영식이는 숫자를 셀 때, 왼손을 이용한다. 엄지손가락부터 시작해서 새끼손가락까지 차례대로 하나씩 센다. 그다음에 새끼손가락까지 센 다음에는 반대로 엄지손가락으로 다시 역방향으로 센다. 영식이는 자기가 원하는 숫자가 나올 때 까지 계속해서 이 방법으로 센다. 영식이는 절대 손가락을 건너뛰지 않는다. 예를 들어 숫자 10을 셀 때는, 엄지->검지->중지->약지->새끼->약지->중지->검지->엄지->검지 이렇게 센다.

슬프게도, 영식이는 민식이와 싸우다가 손가락을 하나 다쳤다. 멍청한 영식이는 오른손으로는 셀 수 없기 때문에, 오늘도 역시 왼손으로 세야 한다. 영식이는 다친 손가락을 아얘 쓸 수 없는 것은 아니고, 셀 수 있는 횟수가 제한되어 있는 것이다.

영식이가 셀 수 있는 최대 숫자를 출력하는 프로그램을 작성하시오. [baekjoon](https://www.acmicpc.net/problem/1614)

<br>

# 코드
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class 영식이의손가락_1614 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int hurt = Integer.parseInt(br.readLine()), flag = 0;
        long limit = Long.parseLong(br.readLine()) - 1, cnt = 5;
        int[] left = {3, 2, 1, 0}, right = {0, 1, 2, 3};

        if (limit < 0) {
            System.out.println(hurt - 1);
            return;
        } else if (limit == 0) {
            int[] tmp = {8, 7, 6, 5, 12};
            System.out.println(tmp[hurt - 1]);
            return;
        }

        while (limit-- > 0) {
            cnt += 4;
            if ((flag == 0 && hurt == 5) || (flag == 1 && hurt == 1)) limit++;
            flag = (flag == 0) ? 1 : 0;
        }

        if ((flag == 0 && hurt == 5) || (flag == 1 && hurt == 1)) {
            cnt += 7;
        } else {
            int n = (flag == 0) ? left[hurt - 1] : right[hurt - 2];
            while (n-- > 0) cnt++;
        }

        System.out.println(cnt);
    }
}
```

<br>

# 풀이
1번째, 5번째 손가락을 두 번 포함해서 세지 않기 때문에 고려하기가 어려웠다. 그래서 처음 5까지는 모든 손가락이 다 더해지니까 그걸 베이스로 두고 그 이후부터는 4씩 더해지되 왼쪽 혹은 오른쪽 방향만 달라지는 걸로 답을 찾아내는 방식으로 풀었다. 

left와 right는 방향이 왼쪽 혹은 오른쪽일때 더해줘야 하는 횟수(=수)를 갖고있는 배열이다. 예를들어, left[0]은 1번째 손가락이 다쳤을 때 더해줘야 하는 횟수고 right[0]은 2번째 손가락이 다쳤을 때 더해줘야하는 횟수이다. 이런식인 이유는 왼쪽 방향일때 4 -> 3 -> 2 -> 1 방향으로 손가락을 세게 되고 오른쪽 방향일때 2 -> 3 -> 4 -> 5 방향으로 손가락을 세기 때문이다.

제한(limit)의 방향에 대한 마지막 수까지 더하면, 이제 아픈 손가락을 만나기 전까지 더해야 하는 횟수를 left 혹은 right 배열로 찾으면 된다.

기본적인 로직은 이렇고, 3가지 정도의 예외 처리를 했다. 첫번째는 input으로 받은 셀 수 있는 횟수가 0인 경우이다. 이때는 그 손가락을 만나기 전까지의 값을 리턴한다. 두번째는 셀 수 있는 횟수가 1인 경우이다. 맨 처음 베이스를 5까지 더한 걸로 뒀기 때문에 그냥 tmp 배열 안에 모든 손가락에 대한 답을 적어서 리턴하게 했다. 마지막 세번째 경우는 첫번째 혹은 세번째 손가락인 경우다. left와 right 방향 둘 다 총 4개의 손가락만 쓰게 되기 때문에 각 방향마다 한 손가락씩 놓치게 된다. 그거에 대한 처리도 필요했다.

맞긴 했지만 최대 2n번까지 while 루프를 돌아야해서 시간이 엄청 느리게 나왔다.. 다른 분들 코드를 보니 1번째거나 5번째 손가락인 경우와 나머지 손가락인 경우 각각 식을 통해 구할 수 있다는 것을 알았다.