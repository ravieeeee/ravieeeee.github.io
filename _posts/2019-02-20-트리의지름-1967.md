---
layout: post
title: "1967번) 트리의 지름"
date:   2019-02-20
categories: [Algorithm]
icon: icon-cplusplus
---

# 문제
트리(tree)는 사이클이 없는 무방향 그래프이다. 트리에서는 어떤 두 노드를 선택해도 둘 사이에 경로가 항상 하나만 존재하게 된다. 트리에서 어떤 두 노드를 선택해서 양쪽으로 쫙 당길 때, 가장 길게 늘어나는 경우가 있을 것이다. 이럴 때 트리의 모든 노드들은 이 두 노드를 지름의 끝 점으로 하는 원 안에 들어가게 된다.

![](https://www.acmicpc.net/JudgeOnline/upload/201007/ttrrtrtr.png)

이런 두 노드 사이의 경로의 길이를 트리의 지름이라고 한다. 정확히 정의하자면 트리에 존재하는 모든 경로들 중에서 가장 긴 것의 길이를 말한다.

입력으로 루트가 있는 트리를 가중치가 있는 간선들로 줄 때, 트리의 지름을 구해서 출력하는 프로그램을 작성하시오. 아래와 같은 트리가 주어진다면 트리의 지름은 45가 된다. [baekjoon](https://www.acmicpc.net/problem/1967)

![](https://www.acmicpc.net/JudgeOnline/upload/201007/tttttt.png)

<br>

# 코드
```c++
#include "1967.h"
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

const int MAX_NODE = 10001;
int n;
vector<pair<int, int>> graph[MAX_NODE];

int getFurthestNode(int from) {
    vector<bool> isVisited(n + 1);
    queue<pair<int, int>> q;
    q.push(make_pair(from, 0));
    isVisited[from] = true;

    int maxDist = 0, idx = 0;
    while (!q.empty()) {
        pair<int, int> node = q.front();
        q.pop();
        if (maxDist < node.second) {
            maxDist = node.second;
            idx = node.first;
        }

        for (pair<int, int> connected : graph[node.first]) {
            if (!isVisited[connected.first]) {
                q.push(make_pair(connected.first, node.second + connected.second));
                isVisited[connected.first] = true;
            }
        }
    }
    return idx;
}

int getDistance(int from, int to) {
    vector<bool> isVisited(n + 1);
    queue<pair<int, int>> q;
    q.push(make_pair(from, 0));
    isVisited[from] = true;

    while (!q.empty()) {
        pair<int, int> node = q.front();
        q.pop();
        for (pair<int, int> connected : graph[node.first]) {
            if (to == connected.first) {
                return node.second + connected.second;
            }

            if (!isVisited[connected.first]) {
                q.push(make_pair(connected.first, node.second + connected.second));
                isVisited[connected.first] = true;
            }
        }
    }
}

void solve_1967() {
    scanf("%d", &n);
    for (int i = 1; i < n; i++) {
        int a, b, c;
        scanf("%d %d %d", &a, &b, &c);
        graph[a].push_back(make_pair(b, c));
        graph[b].push_back(make_pair(a, c));
    }

    int farNode1 = getFurthestNode(1);
    int farNode2 = getFurthestNode(farNode1);
    printf("%d", getDistance(farNode1, farNode2));
}
```

<br>

# 풀이
트리의 어떤 노드던지 잡아서, 그 노드에 대해 가장 멀리있는 노드는 반드시 트리의 지름을 이루는 왼쪽 혹은 오른쪽 노드다. 그게 farNode1에 들어가고, farNode1으로부터 가장 먼 노드는 트리의 지름을 이루는 반대편 노드로 farNode2에 넣어 둘 사이의 거리를 구한다.
