---
layout: post
title: "9997번) 폰트"
date:   2019-01-27
categories: [Algorithm]
icon: icon-cplusplus
---

# 문제
상근이는 자신이 만든 폰트를 테스트하기 위한 문장 만들려고 한다. 폰트에는 알파벳 소문자만 포함되어 있기 때문에, 문장은 알파벳 소문자로 작성해야 한다.

테스트 문장에는 알파벳 소문자 26개가 모두 포함되어 있어야 한다.

사실 문제를 많이 풀어본 사람이라면, 문제를 여기까지 읽어도 무슨 문제인지 감이 잡혀야 한다.

상근이는 단어 N개가 포함되어 있는 사전을 하나 가지고 있다. 테스트 문장은 사전에 포함된 단어만 이용해서 만들 수 있으며, 각 단어는 한 번씩만 사용해야 한다. 또, 단어의 순서는 중요하지 않다. (“uvijek jedem sarmu” 와 “jedem sarmu uvijek”는 같은 문장이다)

상근이가 만들 수 있는 테스트 문장의 개수를 구하는 프로그램을 작성하시오. [baekjoon](https://www.acmicpc.net/problem/9997)

<br>

# 코드
```c++
#include "9997.h"
#include <iostream>

using namespace std;

int n, result;

void checkWords(int flagBits[], int stackedBits, int idx) {
    if (idx == n) {
        if (stackedBits == ((1 << 26) - 1)) result++;
        return;
    }

    checkWords(flagBits, stackedBits, idx + 1);
    checkWords(flagBits, stackedBits | flagBits[idx], idx + 1);
}

void solve_9997() {
    scanf("%d", &n);

    int flagBits[n];
    for (int i = 0; i < n; i++) {
        char s[100];
        scanf("%s", s);
        string word(s);

        flagBits[i] = 0;
        for (int j = 0; j < word.size(); j++) {
            int flag = ((int) word.at(j)) - 97;
            flagBits[i] |= (1 << flag);
        }
    }

    result = 0;
    checkWords(flagBits, 0, 0);
    printf("%d", result);
}
```

<br>

# 풀이
소문자 26개의 등장여부를 비트마스킹을 이용해서 표현해서 체크하는 방식이다. 전체가 1인, 즉 (1 << 26) - 1의 경우에 테스트 문장이 된다. 이것보단 단어 최대 개수가 25개이기 때문에 조합을 for loop으로 만들 수 없어서 재귀적으로 생각하느라 힘들었다..
