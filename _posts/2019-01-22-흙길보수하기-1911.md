---
layout: post
title: "1911번) 흙길 보수하기"
date:   2019-01-22
categories: [Algorithm]
icon: icon-cplusplus
---

# 문제
어젯밤 겨울 캠프 장소에서 월드 본원까지 이어지는, 흙으로 된 비밀길 위에 폭우가 내려서 N (1 <= N <= 10,000) 개의 물웅덩이가 생겼다. 월드학원은 물웅덩이를 덮을 수 있는 길이 L (L은 양의 정수) 짜리 널빤지들을 충분히 가지고 있어서, 이들로 다리를 만들어 물웅덩이들을 모두 덮으려고 한다. 물웅덩이들의 위치와 크기에 대한 정보가 주어질 때, 모든 물웅덩이들을 덮기 위해 필요한 널빤지들의 최소 개수를 구하여라. [baekjoon](https://www.acmicpc.net/problem/1911)

<br>

# 코드
```c++
#include "1911.h"
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

void solve_1911() {
    int n, l;
    cin >> n >> l;
    vector<pair<int, int>> hole;
    for (int i = 0; i < n; i++) {
        int from, to;
        cin >> from >> to;
        hole.push_back(pair<int, int>(from, to));
    }
    sort(hole.begin(), hole.end());

    int result = 0, newPosition = hole.begin()->first;
    vector<pair<int, int>>::iterator iter;
    for (iter = hole.begin(); iter != hole.end(); iter++) {
        if (newPosition < iter->first) newPosition = iter->first;

        bool isMiddle = iter->first <= newPosition && newPosition < iter->second;
        while (isMiddle) {
            newPosition += l;
            result++;
            isMiddle = iter->first <= newPosition && newPosition < iter->second;
        }

        if (newPosition >= iter->second) continue;
    }
    cout << result;
}
```

<br>

# 풀이
시작점 기준으로 정렬한 후, 널빤지를 놓기 시작한다. newPosition에 새로 놓을 index를 관리한다.  
놓으면서 3가지 케이스가 생기는데, 첫번째는 현재 iteration(시작-끝)에서 시작점보다 newPosition이 작은 경우로, 널빤지가 놓아지는 시작점이 정해지는 부분이다. 이 경우에 newPosition에는 웅덩이가 없다는 뜻이므로 newPosition을 현재 iter의 시작점(웅덩이가 다시 시작되는 점)으로 바꾼다. 두번째는 newPosition이 현재 iter의 시작과 끝 사이에 있는 경우다. 이 경우에는 널빤지를 놓아야 하는 경우다. 이렇게 널빤지를 놓다가 iter의 끝점과 만나는 세번째 경우가 되면 다음 iter로 이동한다.  
처음에는 널빤지를 놓은 index를 관리해서 웅덩이가 있는 곳들에 대해서 다 순회하면서 체크하도록 구현했는데, 메모리 초과가 됐다. 위치 최대값이 큰 문제이므로 메모리 제한도 고려 대상이 되었던 것 같다.
