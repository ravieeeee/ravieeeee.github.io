---
layout: post
title: "10866번) 덱"
date:   2018-07-07
categories: [Algorithm]
icon: icon-java
---

# 문제
정수를 저장하는 덱(Deque)를 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.

명령은 총 여덟 가지이다.

* push_front X: 정수 X를 덱의 앞에 넣는다.

* push_back X: 정수 X를 덱의 뒤에 넣는다.

* pop_front: 덱의 가장 앞에 있는 수를 빼고, 그 수를 출력한다. 만약, 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.

* pop_back: 덱의 가장 뒤에 있는 수를 빼고, 그 수를 출력한다. 만약, 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.

* size: 덱에 들어있는 정수의 개수를 출력한다.

* empty: 덱이 비어있으면 1을, 아니면 0을 출력한다.

* front: 덱의 가장 앞에 있는 정수를 출력한다. 만약 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.

* back: 덱의 가장 뒤에 있는 정수를 출력한다. 만약 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다. [baekjoon](https://www.acmicpc.net/problem/10866)

<br>

# 코드
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class 덱_10866 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;
        StringBuilder sb = new StringBuilder();
        int n = Integer.parseInt(br.readLine());
        int[] a = new int[2 * n];
        int f = n, b = n, size = 0;

        while (n-- > 0) {
            st = new StringTokenizer(br.readLine());
            switch (st.nextToken()) {
                case "push_front":
                    if (f == b) b++;
                    size++;
                    a[f--] = Integer.parseInt(st.nextToken());
                    break;
                case "push_back":
                    if (f == b) f--;
                    size++;
                    a[b++] = Integer.parseInt(st.nextToken());
                    break;
                case "pop_front":
                    if (b - f == 2) b--;
                    if (f != b) size--;
                    sb.append((f == b ? -1 : a[++f]) + "\n");
                    break;
                case "pop_back":
                    if (b - f == 2) f++;
                    if (f != b) size--;
                    sb.append((f == b ? -1 : a[--b]) + "\n");
                    break;
                case "size":
                    sb.append(size + "\n");
                    break;
                case "empty":
                    sb.append((size > 0 ? 0 : 1) + "\n");
                    break;
                case "front":
                    sb.append((size == 0 ? -1 : a[f + 1]) + "\n");
                    break;
                case "back":
                    sb.append((size == 0 ? -1 : a[b - 1]) + "\n");
                    break;
            }
        }
        System.out.println(sb.deleteCharAt(sb.length() - 1));
    }
}
```

<br>

# 풀이
배열 자체의 크기를 입력받은 크기보다 2배로 해서 f와 b로 각각 덱의 앞과 뒤의 연산을 할 수 있도록 인덱스를 갖고 있도록 했다. 

계속 틀리는데 반례찾기가 어려워서 질문해서 도움을 받았다. front랑 back을 size로 비어있는지 판단하니까 바로 해결되서 어이가 없었다. 내눈에만 안보이고 남의 눈에만 잘보이는게 가끔 있는 것 같다...
