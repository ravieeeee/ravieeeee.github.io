---
layout: post
title: "2934번) LRH 식물"
date:   2019-01-27
categories: [Algorithm]
icon: icon-cplusplus
---

# 문제
상근이는 유전자 조작을 통해 줄기 두 개로 이루어진 식물을 만들었다. 이 식물은 줄기의 x좌표 L, R과 높이 H로 나타낼 수 있다. 아래 그림은 L=2, R=5, H=4인 식물이다.

![](https://www.acmicpc.net/upload/images/pl.png)

상근이는 매일 매일 화단에 식물을 하나씩 심는다. 첫 번째 날에 심은 식물의 높이는 1이고, 그 다음날에 심은 식물은 전날에 심은 식물의 높이보다 1 크다.

새 식물의 줄기가 다른 식물의 수평 선분과 교차하는 경우가 있다. 이러한 경우에 그 위치에는 꽃이 하나 피게 된다. (이미 꽃이 있는 경우에는 꽃이 더 피지 않는다) 점에서 접하는 경우에는 꽃이 피지 않는다.

아래 그림은 예제를 나타낸 것이다.

![](https://www.acmicpc.net/upload/images/pl2.png)

모든 식물의 좌표가 주어졌을 때, 매일 매일 피는 꽃의 개수를 구하는 프로그램을 작성하시오. [baekjoon](https://www.acmicpc.net/problem/2934)

<br>

# 코드
```c++
#include <iostream>
#include <vector>

using namespace std;

void update(vector<int> &fenwickTree, int idx, int diff) {
    while (idx < fenwickTree.size()) {
        fenwickTree[idx] += diff;
        idx += (idx & -idx);
    }
}

int sum(vector<int> &fenwickTree, int idx) {
    int result = 0;
    while (idx > 0) {
        result += fenwickTree[idx];
        idx -= (idx & -idx);
    }
    return result;
}

void solve_2934() {
    int n;
    cin >> n;

    vector<int> fenwickTree(100001);
    while (n-- > 0) {
        int l, r;
        scanf("%d %d", &l, &r);

        // 해당 좌표 값의 합 출력
        int sum_l = sum(fenwickTree, l), sum_r = sum(fenwickTree, r);
        printf("%d\n", + (sum_l + sum_r));

        // 해당 좌표값 0, 0으로 만들기
        update(fenwickTree, l, -sum_l);
        update(fenwickTree, l + 1, sum_l);
        update(fenwickTree, r, -sum_r);
        update(fenwickTree, r + 1, sum_r);

        // 사이값 + 1 해주기
        update(fenwickTree, l + 1, 1);
        update(fenwickTree, r, -1);
    }
}
```

비트마스크를 이용했던 풀이(시간초과)
```c++
#include <iostream>
#include <map>

using namespace std;

int main() {
    int n;
    cin >> n;

    map<int, int> m;
    int day = 1;
    while (n-- > 0) {
        int l, r;
        scanf("%d %d", &l, &r);

        int visited = 0;
        for (int i = l + 1; i < r; i++) {
            visited |= (1 << i);
        }
        m[day] = visited;

        int result = 0;
        for (int i = 1; i < day; i++) {
            if (m[i] & (1 << l)) {
                result++;
                m[i] &= ~(1 << l);
            }
            if (m[i] & (1 << r)) {
                result++;
                m[i] &= ~(1 << r);
            }
        }
        printf("%d\n", result);
        day++;
    }
}
```

<br>

# 풀이
전혀 감을 못잡겠어서 [풀이](https://toujours.tistory.com/entry/2934LRH-%EC%8B%9D%EB%AC%BC)를 보면서 공부했다. 가장 처음 떠오르는 풀이대로는 O(n^3)이 소요되는 방식이어서 시간 초과가 됐었기 때문이다.  
펜윅트리를 이용하면 풀린다는 것을 알게 된 후에도 해결하기가 어려웠는데, 그 이유가 구간합을 어떤 i~j사이의 합이라고만 생각했기 때문이다. i~i 혹은 j~j의 합을 구하는 데에도 변형해서 이용할 수 있다. 또, sum(i)가 i 위치에서 필 수 있는 꽃의 수를 나타내지만 0~i까지의 트리의 한 index 값에 접근하면 그 값은 아무런 의미를 가지지 않는다는 것이 좀 생소했다.  
어쨌든 배운점은, 구간합을 '대놓고 i~j까지의 합을 구해라!' 문제 뿐만 아니라 변형해서 이용해 본 것과 배열(혹은 벡터 등)에서 특정 index 값은 의미를 가지진 않지만 sum 같은 산술연산 값이 의미를 나타낼 수 있다는 것이다.
