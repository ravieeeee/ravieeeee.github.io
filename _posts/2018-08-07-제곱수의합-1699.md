---
layout: post
title: "1699번) 제곱수의 합"
date:   2018-08-07
categories: [Algorithm]
icon: icon-java
---

# 문제
어떤 자연수 N은 그보다 작거나 같은 제곱수들의 합으로 나타낼 수 있다. 예를 들어 11=32+12+12(3개 항)이다. 이런 표현방법은 여러 가지가 될 수 있는데, 11의 경우 11=22+22+12+12+12(5개 항)도 가능하다. 이 경우, 수학자 숌크라테스는 “11은 3개 항의 제곱수 합으로 표현할 수 있다.”라고 말한다. 또한 11은 그보다 적은 항의 제곱수 합으로 표현할 수 없으므로, 11을 그 합으로써 표현할 수 있는 제곱수 항의 최소 개수는 3이다.

주어진 자연수 N을 이렇게 제곱수들의 합으로 표현할 때에 그 항의 최소개수를 구하는 프로그램을 작성하시오. [baekjoon](https://www.acmicpc.net/problem/1699)

<br>

# 코드
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class 제곱수의합_1699 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        br.close();

        int[] dp = new int[n + 1];
        if (n == (int) Math.sqrt(n) * (int) Math.sqrt(n)) {
            System.out.println(1);
            return;
        }

        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            if (i == (int) Math.sqrt(i) * (int) Math.sqrt(i)) {
                dp[i] = 1;
                continue;
            }
            
            for (int j = 1; j <= i / 2; j++) {
                dp[i] = (j == 1) ? dp[j] + dp[i - j] : Math.min(dp[i], dp[j] + dp[i - j]);
            }
        }
        System.out.println(dp[n]);
    }
}
```

<br>

# 풀이
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class 제곱수의합_1699 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine()), copyN = n,
                m = 0, r = 0;
        br.close();

        while (m != copyN) {
            n = (int) Math.sqrt(copyN - m);
            m += n * n;
            r++;
        }
        System.out.println(r);
    }
}
```
처음엔 n의 제곱근부터 1까지의 수들 중에 가장 큰 수를 더해가면 항의 개수가 최소가 될거라고 생각했다. 걍 멍청이었다; 바로 반례를 찾았다.

![pic](../assets/1699.png)

위 코드로 99999에 대한 최소개수는 6개가 되는데, 오른쪽처럼 5개로 줄일 수도 있고 실제로 최소 개수는 4개다. 그래서 바꿔서 푼 방법은 11에 대한 최소개수를 구한다면 11 = 0+11, 1+10, 2+9, ... 중에 최소 개수를 찾는 것이다. dp지만 완전탐색같이 풀어버려서 시간이 진짜 엄청 오래걸렸다.

가장 dp스러운 풀이방식은 min(dp[n - i * i] + 1)를 찾는 방식인것 같다.
