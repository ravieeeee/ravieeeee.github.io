---
layout: post
title: "1952번) 달팽이2"
date:   2019-08-16
categories: [Algorithm]
icon: icon-cplusplus
---

# 문제
M줄 N칸으로 되어 있는 표 위에, 달팽이 모양으로 선을 그리려고 한다.

| o |   |   |
|---|---|---|
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |

위의 그림은 M=5, N=3의 예이다. 이제 표의 왼쪽 위 칸(ㅇ)에서 시작하여, 오른쪽으로 선을 그려 나간다. 표의 바깥 또는 이미 그려진 칸에 닿아서 더 이상 이동할 수 없게 되면, 시계방향으로 선을 꺾어서 그려나간다.

| o | →  | ↘ |
|---|----|---|
| ↗ | ↘  | ↓ |
| ↑ | ↓  | ↓ |
| ↑ | 끝 | ↓ |
| ↖ | ←  | ↙ |

위의 표는 선을 그려 나간 모양을 나타낸 것이다. (선이 꺾어진 부분은 대각선으로 나타내었다. 표의 모든 칸이 채워질 때까지, 선을 몇 번 꺾게 될까? [baekjoon](https://www.acmicpc.net/problem/1952)

<br>

# 코드
```c++
#include "1952.h"
#include <iostream>

using namespace std;

void solve_1952() {
    int m, n;
    cin >> m >> n;
    bool is_visited[m][n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            is_visited[i][j] = false;
        }
    }

    int startX = 0, startY = 0, result = -1;
    while (true) {
        if (!is_visited[startX][startY]) {
            for (int j = startY; j < n; j++) is_visited[startX][j] = true;
            result++;
        } else {
            break;
        }

        if (!is_visited[startX + 1][n - 1]) {
            for (int i = startX + 1; i < m; i++) is_visited[i][n - 1] = true;
            result++;
        } else {
            break;
        }

        if (!is_visited[m - 1][n - 2]) {
            for (int j = n - 2; j >= startY; j--) is_visited[m - 1][j] = true;
            result++;
        } else {
            break;
        }

        if (!is_visited[m - 2][startY]) {
            for (int i = m - 2; i >= startX; i--) is_visited[i][startY] = true;
            result++;
        } else {
            break;
        }

        startX++; startY++;
        m--; n--;
    }

    cout << result << endl;
}
```

<br>

# 풀이
.
