---
layout: post
title: "9084번) 동전"
date:   2018-07-07
categories: [Algorithm]
icon: icon-java
---

# 문제
우리나라 화폐단위, 특히 동전에는 1원, 5원, 10원, 50원, 100원, 500원이 있다. 이 동전들로는 모두 정수의 금액을 만들 수 있으며 그 방법도 여러 가지가 있을 수 있다. 예를 들어, 30원을 만들기 위해서는 1원짜리 30개 또는 10원짜리 2개와 5원짜리 2개 등의 방법이 가능하다.

동전의 종류가 주어질 때에 주어진 금액을 만드는 모든 방법을 세는 프로그램을 작성하시오. [baekjoon](https://www.acmicpc.net/problem/9084)

<br>

# 코드
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class 동전_9084 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();
        StringTokenizer st;

        int t = Integer.parseInt(br.readLine());
        while (t-- > 0) {
            int n = Integer.parseInt(br.readLine());
            st = new StringTokenizer(br.readLine());
            int w = Integer.parseInt(br.readLine());

            int[] y = new int[n], dp = new int[w + 1];

            for (int i = 0; i < n; i++) y[i] = Integer.parseInt(st.nextToken());

            dp[0] = 1;
            for (int i = 0; i < n; i++) {
                for (int j = y[i]; j <= w; j++) {
                    dp[j] += dp[j - y[i]];
                }
            }
            sb.append(dp[w] + "\n");
        }
        System.out.println(sb.deleteCharAt(sb.length() - 1));
    }
}
```

<br>

# 풀이
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class 동전_9084 {
    static int[] dp;
    static int[] y;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();
        int t = Integer.parseInt(br.readLine());
        while (t-- > 0) {
            int n = Integer.parseInt(br.readLine());
            y = new int[n];
            StringTokenizer st = new StringTokenizer(br.readLine());
            int w = Integer.parseInt(br.readLine()), z = 0;
            dp = new int[w + 1];
            while (st.hasMoreTokens()) {
                int x = Integer.parseInt(st.nextToken());
                y[z] = x;
                dp[x] = 1;
                z++;
            }
            coin(w);
            sb.append(dp[w] + "\n");
        }
        System.out.println(sb.deleteCharAt(sb.length() - 1));
    }

    static int coin(int n) {
        if (dp[n] != 0) return dp[n];

        for (int i = 0; i < y.length; i++) {
            if (n > y[i]) dp[n] += coin(n - y[i]);
        }

        return dp[n];
    }
}
```

처음 풀었던 방식이 위의 방식인데, (마지막 입력 test case를 예시로 들면)이렇게 하면 5+7과 7+5를 구분할 수 없었다. 왜냐하면 만들고자 하는 금액에 대해서 계속 갈래가 나눠지다보니 그 금액을 이루는 방법이 5+7이든 7+5이든 각 case간에 서로 알지 못하기 때문이다. 슬프지만 왜틀렸는지 그려보았다...

![pic](../assets/coin.png)

이를 해결하기 위해서 오히려 한 동전에 대해서 금액에 대한 경우의 수를 구하도록 해서 여러 case가 나올 수 없도록 했다. 즉, 순서가 존재할 수 없는 것이다.
