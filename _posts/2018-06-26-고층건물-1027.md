---
layout: post
title: "1027번) 고층 건물"
date:   2018-06-26
categories: [Algorithm]
icon: icon-java
---

# 문제
세준시에는 고층 빌딩이 많다. 세준시의 서민 김지민은 가장 많은 고층 빌딩이 보이는 고층 빌딩을 찾으려고 한다. 빌딩은 총 N개가 있는데, 빌딩은 선분으로 나타낸다. i번째 빌딩 (1부터 시작)은 (i,0)부터 (i,높이)의 선분으로 나타낼 수 있다. 고층 빌딩 A에서 다른 고층 빌딩 B가 볼 수 있는 빌딩이 되려면, 두 지붕을 잇는 선분이 A와 B를 제외한 다른 고층 빌딩을 지나거나 접하지 않아야 한다. 가장 많은 고층 빌딩이 보이는 빌딩을 구하고, 거기서 보이는 빌딩의 수를 출력하는 프로그램을 작성하시오. [baekjoon](https://www.acmicpc.net/problem/1027)

<br>

# 코드
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class 고층건물_1027 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine()), max = 0;
        StringTokenizer st = new StringTokenizer(br.readLine());
        long[] a = new long[n];
        for (int i = 0; i < n; i++) a[i] = Integer.parseInt(st.nextToken());

        for (int i = 0; i < n; i++) {
            int tmp = 0;

            for (int j = i - 1; j >= 0; j--) {
                int flag = 0;

                for (int l = i - 1; l > j; l--) {
                    if (isCross(j + 1, a[j], i + 1, a[i],
                            l + 1, a[l], l + 1, 0) == 1) {
                        flag = 1;
                        break;
                    }
                }
                if (flag == 0) tmp++;
            }

            for (int k = i + 1; k < n; k++) {
                int flag = 0;

                for (int l = i + 1; l < k; l++) {
                    if (isCross(i + 1, a[i], k + 1, a[k],
                            l + 1, a[l], l + 1, 0) == 1) {
                        flag = 1;
                        break;
                    }
                }
                if (flag == 0) tmp++;
            }
            if (tmp > max) max = tmp;
        }
        System.out.println(max);
    }

    static int ccw(long x1, long y1, long x2, long y2, long x3, long y3) {
        long x = x1*y2 + x2*y3 + x3*y1 - (x2*y1 + x3*y2 + x1*y3);

        return x > 0 ? 1 : ((x == 0L) ? 0 : -1);
    }

    static int isCross(long ax, long ay, long bx, long by, long cx, long cy, long dx, long dy) {
        int ccw1 = ccw(ax, ay, bx, by, cx, cy);
        int ccw2 = ccw(ax, ay, bx, by, dx, dy);
        int ccw3 = ccw(cx, cy, dx, dy, bx, by);
        int ccw4 = ccw(cx, cy, dx, dy, ax, ay);

        return (ccw1 * ccw2 <= 0 && ccw3 * ccw4 <= 0) ? 1 : 0;
    }
}
```

<br>

# 풀이
돌면서 왼쪽 오른쪽에 대해서 각각 CCW 알고리즘을 사용해서 교차하는지 체크하도록 했다. 

한 번 틀렸었는데, 그 때 놓쳤던 테스트케이스가 왼쪽이든 오른쪽이든 가다가 교차하게 된 빌딩이 생기더라도 이후에 압도적으로 높은 빌딩이 나올 수 있다는 거다. 결국 모든 빌딩에 대해 체크해야 한다.