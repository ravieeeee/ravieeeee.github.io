---
layout: post
title: "11054번) 가장 긴 바이토닉 부분 수열"
date:   2019-02-11
categories: [Algorithm]
icon: icon-cplusplus
---

# 문제
수열 S가 어떤 수 Sk를 기준으로 S1 < S2 < ... Sk-1 < Sk > Sk+1 > ... SN-1 > SN을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.

예를 들어, {10, 20, 30, 25, 20}과 {10, 20, 30, 40}, {50, 40, 25, 10} 은 바이토닉 수열이지만,  {1, 2, 3, 2, 1, 2, 3, 2, 1}과 {10, 20, 30, 40, 20, 30} 은 바이토닉 수열이 아니다.

수열 A가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하시오. [baekjoon](https://www.acmicpc.net/problem/11054)

<br>

# 코드
```c++
#include "11054.h"
#include <iostream>

using namespace std;

void solve_11054() {
    int n;
    scanf("%d", &n);

    int inputValue[n];
    for (int i = 0; i < n; i++) scanf("%d", &inputValue[i]);

    int up[n], down[n];
    for (int i = 0; i < n; i++) {
        up[i] = 1;
        for (int j = 0; j < i; j++) {
            if (inputValue[j] < inputValue[i] && up[i] < up[j] + 1) {
                up[i] = up[j] + 1;
            }
        }
    }

    for (int i = n - 1; i >= 0; i--) {
        down[i] = 1;
        for (int j = i + 1; j < n; j++) {
            if (inputValue[j] < inputValue[i] && down[i] < down[j] + 1) {
                down[i] = down[j] + 1;
            }
        }
    }

    int maxLength = up[0] + down[0] - 1;
    for (int i = 1; i < n; i++) {
        if (maxLength < up[i] + down[i] - 1) maxLength = up[i] + down[i] - 1;
    }
    printf("%d", maxLength);
}
```

<br>

# 풀이
up[i]와 down[i]는 i를 마지막으로 포함하면서 만드는 가장 긴 증가 수열을 담는다. down 배열을 채울 때 역방향으로 조사해서 i가 n에서 0으로 갈수록 더 긴 수열을 포함하게끔 한다. 문제에서는 감소 방향이지만 방향을 바꿨기 때문에 반대로 input[i] > input[j]가 되는 값들을 체크해서 포함시켜야 한다.
