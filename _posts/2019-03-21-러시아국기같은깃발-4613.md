---
layout: post
title: "SWEA 4613번) 러시아 국기 같은 깃발"
date:   2019-03-21
categories: [Algorithm]
icon: icon-cplusplus
---

# 문제
[SWEA](https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWQl9TIK8qoDFAXj&categoryId=AWQl9TIK8qoDFAXj&categoryType=CODE)

<br>

# 코드
```c++
#include "4613.h"
#include <iostream>
#include <vector>

using namespace std;

void solve_4613() {
    int tc;
    cin >> tc;
    for (int test_case = 1; test_case <= tc; test_case++) {
        int n, m;
        cin >> n >> m;

        int result = 0;
        // 후보 층들을 담을 곳
        vector<int> colors[n - 2];
        for (int i = 0; i < n; i++) {
            char line[m];
            scanf("%s", line);

            int w = 0, r = 0, b = 0;
            for (int j = 0; j < m; j++) {
                switch (line[j]) {
                    case 'W': w++; break;
                    case 'B': b++; break;
                    case 'R': r++; break;
                }
            }

            if (i == 0) {
                // 첫번째 줄 -> 무조건 W
                result += m - w;
            } else if (i == n - 1) {
                // 마지막 줄 -> 무조건 R
                result += m - r;
            } else {
                colors[i - 1].push_back(w); colors[i - 1].push_back(b); colors[i - 1].push_back(r);
            }
        }

        int min_coloring = n * m;
        for (int from = 0; from < n - 2; from++) {
            for (int to = from; to < n - 2; to++) {

                int tmp_coloring = 0;
                for (int line = 0; line < n - 2; line++) {
                    if (line < from) {
                        // W
                        tmp_coloring += m - colors[line].at(0);
                    } else if (from <= line && line <= to) {
                        // B
                        tmp_coloring += m - colors[line].at(1);
                    } else {
                        // R
                        tmp_coloring += m - colors[line].at(2);
                    }
                }

                if (tmp_coloring < min_coloring) min_coloring = tmp_coloring;
            }
        }

        cout << "#" << test_case << " " << result + min_coloring << endl;
    }
}
```

<br>

# 풀이
맨 윗줄은 무조건 흰색줄이고, 맨 아랫줄은 무조건 빨간줄이다. 그 사이에 있는 줄들에 대해서만 어떤 색깔이 될 지 조사하면 된다. 그 검사할 줄들을 담는 것이 vector를 담는 colors 배열이다. 각 vector의 크기는 3으로, 해당 라인의 W, B, R의 개수가 순차적으로 들어간다.  
담은 line들의 최적을 조사하기 위해, B가 될 line의 범위를 정한다. 2중 for loop의 from과 to가 그 범위다. 잡은 범위에 대해서 조사해야할 line들을 한 번 순회한다. 해당 범위 이전이면 W, 범위면 B, 범위 이후면 R을 칠하는 방식이다.
