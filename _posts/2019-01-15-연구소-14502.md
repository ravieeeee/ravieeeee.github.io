---
layout: post
title: "14502번) 연구소"
date:   2019-01-15
categories: [Algorithm]
icon: icon-java
---

# 문제
인체에 치명적인 바이러스를 연구하던 연구소에서 바이러스가 유출되었다. 다행히 바이러스는 아직 퍼지지 않았고, 바이러스의 확산을 막기 위해서 연구소에 벽을 세우려고 한다.

연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽으로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다. 

일부 칸은 바이러스가 존재하며, 이 바이러스는 상하좌우로 인접한 빈 칸으로 모두 퍼져나갈 수 있다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다.

예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자.

2 0 0 0 1 1 0  
0 0 1 0 1 2 0  
0 1 1 0 1 0 0  
0 1 0 0 0 0 0  
0 0 0 0 0 1 1  
0 1 0 0 0 0 0  
0 1 0 0 0 0 0  

이때, 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 곳이다. 아무런 벽을 세우지 않는다면, 바이러스는 모든 빈 칸으로 퍼져나갈 수 있다.

2행 1열, 1행 2열, 4행 6열에 벽을 세운다면 지도의 모양은 아래와 같아지게 된다.

2 1 0 0 1 1 0  
1 0 1 0 1 2 0  
0 1 1 0 1 0 0  
0 1 0 0 0 1 0  
0 0 0 0 0 1 1  
0 1 0 0 0 0 0  
0 1 0 0 0 0 0  

바이러스가 퍼진 뒤의 모습은 아래와 같아진다.

2 1 0 0 1 1 2  
1 0 1 0 1 2 2  
0 1 1 0 1 2 2  
0 1 0 0 0 1 2  
0 0 0 0 0 1 1  
0 1 0 0 0 0 0  
0 1 0 0 0 0 0  

벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 한다. 위의 지도에서 안전 영역의 크기는 27이다.

연구소의 지도가 주어졌을 때 얻을 수 있는 안전 영역 크기의 최댓값을 구하는 프로그램을 작성하시오. [baekjoon](https://www.acmicpc.net/problem/14502)

<br>

# 코드
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.StringTokenizer;

public class 연구소_14502 {
    static int n, m;
    static int[][] graph, graphCopy;
    static boolean[][] isVisited;
    static LinkedList<int[]> viruses;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        graph = new int[n + 1][m + 1];
        viruses = new LinkedList<>();
        for (int i = 1; i <= n; i++) {
            st = new StringTokenizer(br.readLine());
            for (int j = 1; j <= m; j++) {
                int input = Integer.parseInt(st.nextToken());
                graph[i][j] = input;
                if (input == 2) viruses.add(new int[] {i, j});
            }
        }
        br.close();

        init();
        int maxDots = n * m, result = 0;

        for (int i = 1; i <= maxDots - 2; i++) {
            int[] dot1 = getPosition(i);
            if (!isWall(dot1[0], dot1[1])) continue;

            for (int j = i + 1; j <= maxDots - 1; j++) {
                int[] dot2 = getPosition(j);
                if (!isWall(dot2[0], dot2[1])) continue;

                for (int k = j + 1; k <= maxDots; k++) {
                    int[] dot3 = getPosition(k);
                    if (!isWall(dot3[0], dot3[1])) continue;

                    build3Walls(dot1, dot2, dot3);
                    for (int[] virus : viruses) {
                        int x = virus[0], y = virus[1];
                        if (!isVisited[x][y] && graphCopy[x][y] == 2) {
                            dfs(x, y);
                        }
                    }

                    int safeArea = getSafeArea();
                    if (result < getSafeArea()) result = safeArea;
                    init();
                }
            }
        }

        System.out.println(result);
    }

    static void init() {
        isVisited = new boolean[n + 1][m + 1];
        if (graphCopy == null) graphCopy = new int[n + 1][];
        for (int i = 1; i <= n; i++) graphCopy[i] = Arrays.copyOf(graph[i], graph[i].length);
    }

    static int[] getPosition(int num) {
        int x = num / m + 1, y = num % m;
        if (num % m == 0) {
            x -= 1;
            y = m;
        }
        return new int[] {x, y};
    }

    static boolean isWall(int x, int y) {
        return graph[x][y] == 0;
    }
    
    static void build3Walls(int[] dot1, int[] dot2, int[] dot3) {
        graphCopy[dot1[0]][dot1[1]] = graphCopy[dot2[0]][dot2[1]] = graphCopy[dot3[0]][dot3[1]] = 1;
    }

    static void dfs(int x, int y) {
        isVisited[x][y] = true;
        graphCopy[x][y] = 2;
        // 상
        if (x != 1 && !isVisited[x - 1][y] && graphCopy[x - 1][y] == 0) dfs(x - 1, y);
        // 하
        if (x != n && !isVisited[x + 1][y] && graphCopy[x + 1][y] == 0) dfs(x + 1, y);
        // 좌
        if (y != 1 && !isVisited[x][y - 1] && graphCopy[x][y - 1] == 0) dfs(x, y - 1);
        // 우
        if (y != m && !isVisited[x][y + 1] && graphCopy[x][y + 1] == 0) dfs(x, y + 1);
    }

    static int getSafeArea() {
        int num = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (graphCopy[i][j] == 0) num++;
            }
        }
        return num;
    }
}
```

<br>

# 풀이
그래프는 인접 배열로 만들었지만 바이러스는 그 시작점부터 DFS를 수행해야 하기 때문에 인접 리스트로 만들어서 좌표를 관리했다. 각 좌표에 대해서 조합(n * m개 중에 하나)을 뽑을 때, 편의를 위해 순서대로 1 ~ n * m 사이의 번호를 가진다고 가정했다. 실제 2차원 배열의 index는 getPosition에서 구한다.  
새로운 3개의 벽은 모든 가능한 벽들의 조합 중에 고르게 된다. 벽을 세운 후에 바이러스의 시작점부터 DFS를 수행한 결과 남아있는 안전 영역의 크기를 구하게 된다. DFS가 수행되는 조건은 배열의 index 범위를 벗어나지 않으면서 방문하지 않았고 현재 벽인 상태인 좌표에 대해서 수행된다.
