---
layout: post
title: "6593번) 상범 빌딩"
date:   2019-03-27
categories: [Algorithm]
icon: icon-cplusplus
---

# 문제
당신은 상범 빌딩에 갇히고 말았다. 여기서 탈출하는 가장 빠른 길은 무엇일까? 상범 빌딩은 각 변의 길이가 1인 정육면체(단위 정육면체)로 이루어져있다. 각 정육면체는 금으로 이루어져 있어 지나갈 수 없거나, 비어있어서 지나갈 수 있게 되어있다. 당신은 각 칸에서 인접한 6개의 칸(동,서,남,북,상,하)으로 1분의 시간을 들여 이동할 수 있다. 즉, 대각선으로 이동하는 것은 불가능하다. 그리고 상범 빌딩의 바깥면도 모두 금으로 막혀있어 출구를 통해서만 탈출할 수 있다.

당신은 상범 빌딩을 탈출할 수 있을까? 만약 그렇다면 얼마나 걸릴까? [baekjoon](https://www.acmicpc.net/problem/6593)

<br>

# 코드
```c++
#include "6593.h"
#include <iostream>
#include <queue>

using namespace std;

struct Node {
    int x;
    int y;
    int z;
};
char graph[31][31][31];
bool is_visited[31][31][31];

bool is_visitable(int i, int j, int k) {
    return !is_visited[i][j][k] && graph[i][j][k] != '#';
}

void solve_6593() {
    while (true) {
        int l, r, c;
        cin >> l >> r >> c;
        if (l == 0 && r == 0 && c == 0) break;

        Node start;
        for (int i = 1; i <= l; i++) {
            for (int j = 1; j <= r; j++) {
                string input_line;
                cin >> input_line;
                for (int k = 1; k <= c; k++) {
                    graph[i][j][k] = input_line.at(k - 1);
                    is_visited[i][j][k] = false;
                    if (graph[i][j][k] == 'S') start = { i, j, k };
                }
            }
        }

        queue<pair<Node, int>> q;
        q.push(make_pair(start, 0));
        is_visited[start.x][start.y][start.z] = true;

        bool does_exit_possible = false;
        while (!q.empty()) {
            pair<Node, int> p = q.front();
            q.pop();

            if (graph[p.first.x][p.first.y][p.first.z] == 'E') {
                cout << "Escaped in " << p.second << " minute(s)." << endl;
                does_exit_possible = true;
                break;
            }

            // 상
            if (p.first.y - 1 > 0 && is_visitable(p.first.x, p.first.y - 1, p.first.z)) {
                Node node = { p.first.x, p.first.y - 1, p.first.z };
                q.push(make_pair(node, p.second + 1));
                is_visited[p.first.x][p.first.y - 1][p.first.z] = true;
            }
            // 하
            if (p.first.y + 1 <= r && is_visitable(p.first.x, p.first.y + 1, p.first.z)) {
                Node node = { p.first.x, p.first.y + 1, p.first.z };
                q.push(make_pair(node, p.second + 1));
                is_visited[p.first.x][p.first.y + 1][p.first.z] = true;
            }
            // 좌
            if (p.first.z - 1 > 0 && is_visitable(p.first.x, p.first.y, p.first.z - 1)) {
                Node node = { p.first.x, p.first.y, p.first.z - 1 };
                q.push(make_pair(node, p.second + 1));
                is_visited[p.first.x][p.first.y][p.first.z - 1] = true;
            }
            // 우
            if (p.first.z + 1 <= c && is_visitable(p.first.x, p.first.y, p.first.z + 1)) {
                Node node = { p.first.x, p.first.y, p.first.z + 1 };
                q.push(make_pair(node, p.second + 1));
                is_visited[p.first.x][p.first.y][p.first.z + 1] = true;
            }
            // 앞
            if (p.first.x - 1 > 0 && is_visitable(p.first.x - 1, p.first.y, p.first.z)) {
                Node node = { p.first.x - 1, p.first.y, p.first.z };
                q.push(make_pair(node, p.second + 1));
                is_visited[p.first.x - 1][p.first.y][p.first.z] = true;
            }
            // 뒤
            if (p.first.x + 1 <= l && is_visitable(p.first.x + 1, p.first.y, p.first.z)) {
                Node node = { p.first.x + 1, p.first.y, p.first.z };
                q.push(make_pair(node, p.second + 1));
                is_visited[p.first.x + 1][p.first.y][p.first.z] = true;
            }
        }

        if (!does_exit_possible) cout << "Trapped!" << endl;
    }
}
```

<br>

# 풀이
3차원이라는 것에만 이전에 풀어본 문제들과 차이가 있다. 상하좌우앞뒤 방향에 대해서 방문할 수 있는 점들을 체크한다.
